[{"content":"Figure AI Helix ç³»ç»Ÿæ€»ç»“ ç¡¬ä»¶ç»„æˆ æ„ŸçŸ¥ç³»ç»Ÿï¼šFigure 02çš„å¤´éƒ¨ã€å‰èº¯å¹²å’Œåèº¯å¹²å…±é…å¤‡6ä¸ªRGBæ‘„åƒå¤´ å†³ç­–ç³»ç»Ÿï¼šåµŒå…¥å¼æ§åˆ¶æ¿åŠ2å—æ¿è½½ä½åŠŸè€—GPUsï¼ˆNVIDIA RTX GPUï¼Œå…·ä½“å‹å·æš‚ä¸æ˜ç¡®ï¼‰å‚è€ƒæ¥æº æ‰§è¡Œç³»ç»Ÿï¼šäººå½¢ä¸Šèº«ï¼Œè…°éƒ¨+å¤´éƒ¨+åŒè‡‚å…±35ä¸ªå…³èŠ‚ï¼ˆä»ç…§ç‰‡æ¨æµ‹ï¼Œå¤´2 + è…°3 + è‡‚7x2 + æ‰‹16x2ï¼‰ï¼Œéƒ¨åˆ†æ‰‹éƒ¨è‡ªç”±åº¦åº”è¯¥æ²¡æœ‰ç”¨åˆ° ç½‘ç»œç»“æ„ VLAç½‘ç»œç”±è§£è€¦çš„ä¸¤ä¸ªç³»ç»Ÿâ€”â€”é¢„è®­ç»ƒè§†è§‰è¯­è¨€æ¨¡å‹ï¼ˆS2ï¼‰ + æ§åˆ¶å°æ¨¡å‹ï¼ˆS1ï¼‰ç»„æˆï¼Œä¸¤è€…åœ¨å„è‡ªçš„æ—¶é—´å°ºåº¦ä¸Šè¿è¡Œï¼Œç»“åˆVLMæ¨¡å‹å¹¿æ³›é€šç”¨ä½†ä¸å¤Ÿå¿«çš„ç‰¹ç‚¹å’Œè§†è§‰è¿åŠ¨ç­–ç•¥å¿«é€Ÿè€Œä¸å¹¿æ³›çš„ç‰¹ç‚¹ï¼Œå®ç°ä¸€ä¸ªæ—¢å¹¿æ³›åˆå¿«é€Ÿçš„VLAæ§åˆ¶æ¨¡å‹ã€‚\nS2 å‚æ•°é‡ï¼š7B\nç±»å‹ï¼šå¼€æºVLM\nè¾“å…¥ï¼šRGBå›¾ç‰‡ã€å…³èŠ‚è§’ä¿¡æ¯\nè¾“å‡ºï¼šæ½œç©ºé—´å‘é‡\nè¾“å‡ºé¢‘ç‡ï¼š7-9Hz\nä½œç”¨ï¼šåœºæ™¯ç†è§£å’Œè¯­ä¹‰ç†è§£ï¼Œæä¾›è·¨ç‰©ä½“å’Œåœºæ™¯çš„æ³›åŒ–èƒ½åŠ›ï¼Œå°†æ‰€æœ‰ä¸è¯­ä¹‰ä»»åŠ¡ç›¸å…³çš„ä¿¡æ¯æç‚¼åˆ°ä¸€ä¸ªå•ä¸€çš„è¿ç»­æ½œåœ¨å‘é‡ä¸­ï¼Œå¹¶å°†å…¶ä¼ é€’ç»™S1\nS1 å‚æ•°é‡ï¼š80M\nç±»å‹ï¼šäº¤å‰æ³¨æ„åŠ›çš„ç¼–è§£ç Transformerç½‘ç»œï¼Œä¾èµ–ä¸€ä¸ªå¤šå°ºåº¦çš„å…¨å·ç§¯è§†è§‰éª¨å¹²è¿›è¡Œè§†è§‰å¤„ç†ï¼ˆåœ¨ä»¿çœŸå™¨ä¸­é¢„è®­ç»ƒåˆå§‹åŒ–*ï¼‰\nè¾“å…¥ï¼šæ½œç©ºé—´å‘é‡ã€RGBå›¾ç‰‡ã€å…³èŠ‚è§’\nè¾“å‡ºï¼šé«˜é¢‘æœºå™¨äººåŠ¨ä½œï¼ˆå…³èŠ‚è§’ï¼‰\nè¾“å‡ºé¢‘ç‡ï¼š200Hz\nä½œç”¨ï¼šå¿«é€Ÿçµå·§çš„æ§åˆ¶ç­–ç•¥ï¼Œç»“åˆå›¾åƒç¼–ç å’Œå½“å‰å…³èŠ‚è§’ä¿¡æ¯ï¼Œå°†æ½œç©ºé—´å‘é‡è¡¨ç¤ºè½¬åŒ–æˆè¿ç»­çš„æœºå™¨äººåŠ¨ä½œï¼ˆç›®æ ‡å…³èŠ‚è§’ï¼‰\nè®­ç»ƒç»†èŠ‚ï¼š è®­ç»ƒæ•°æ®ï¼šçº¦500hçš„é«˜è´¨é‡ã€å¤šæœºå™¨äººã€å¤šæ“ä½œå‘˜çš„å¤šæ ·åŒ–é¥æ“ä½œè¡Œä¸ºæ•°æ®é›†\nè®­ç»ƒæ–¹æ³•ï¼šåŸºäºraw pixelå’Œæ–‡æœ¬æŒ‡ä»¤åˆ°è¿ç»­åŠ¨ä½œçš„æ˜ å°„ï¼Œåšç«¯åˆ°ç«¯çš„è®­ç»ƒï¼Œé‡‡ç”¨æ ‡å‡†çš„å›å½’æŸå¤±ã€‚æ¢¯åº¦ä»S1é€šè¿‡æ½œè¡¨ç¤ºå‘é‡ä¼ é€’åˆ°S2ï¼Œå®ç°ä¸¤è€…çš„ååŒä¼˜åŒ–ã€‚\næ³¨æ„ï¼š\nS1å’ŒS2åœ¨è®­ç»ƒé˜¶æ®µæ˜¯è€¦åˆçš„ ä¸ºäº†æ¨¡æ‹ŸçœŸå®çš„æ¨ç†å»¶è¿Ÿï¼Œåœ¨è®­ç»ƒé˜¶æ®µè®¤ä¸ºå¼•å…¥äº†S1å’ŒS2è¾“å…¥é‡çš„æ—¶é—´åç§»* è°ƒä¼˜çš„æµå¼æ¨ç† S1å’ŒS2åˆ†åˆ«è¿è¡Œåœ¨ä¸€å—ä¸“é—¨çš„GPUä¸Šï¼ŒåŸºäºå…±äº«çš„å†…å­˜å½¢æˆä¸€ä¸ªç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ã€‚\nS2å¼‚æ­¥åœ°å¤„ç†æœ€æ–°çš„è§‚æµ‹ä¿¡æ¯å’Œè‡ªç„¶è¯­è¨€æŒ‡ä»¤ï¼Œ æŒç»­åœ°ç”Ÿæˆç¼–ç äº†é«˜ç»´æ„å›¾è¡Œä¸ºæ„å›¾çš„æ½œå‘é‡ï¼Œå¹¶æ›´æ–°åˆ°å…±äº«å†…å­˜ä¸­ã€‚\nS1åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­ï¼Œç»“åˆæœ€æ–°è§‚æµ‹å’Œè‡ªç„¶è¯­è¨€æŒ‡ä»¤ï¼Œæ¶ˆè´¹å…±äº«å†…å­˜ä¸­çš„æ½œå‘é‡ç”Ÿæˆè¿ç»­çš„æœºå™¨äººåŠ¨ä½œã€‚ç”±äºS1æ¯”S2æœ‰æ›´é«˜çš„æ¨ç†é€Ÿåº¦ï¼Œå› æ­¤æœ‰æ›´é«˜çš„æ—¶é—´åˆ†è¾¨ç‡ï¼Œä»è€Œå¯ä»¥å®ç°æ›´ç´§å¯†çš„é—­ç¯å®æ—¶æ§åˆ¶ã€‚\næ•°æ®æµä¸ä¼ è¾“å¸¦å®½ æ•°æ®æµ Sensorä»¥20Hzçš„é¢‘ç‡é‡‡é›†å›¾åƒå’Œå…³èŠ‚è§’ã€‚\nObservationï¼ˆraw_imgï¼‰ â”€â”€â”€â”€ä¼ æ„Ÿå™¨å›¾åƒâ”€â”€â”€â”€\u0026gt;å¤šå°ºåº¦ç«‹ä½“è§†è§‰ç½‘ç»œ â”€â”€â”€â”€åˆå¹¶å›¾åƒç‰¹å¾â”€â”€â”€â”€\u0026gt; Observationï¼ˆcombind_img_tokenï¼‰\nObservationï¼ˆcommand + state + combind_img_tokenï¼‰â”€â”€â”€â”€79Hzè§‚æµ‹ä¿¡æ¯â”€â”€â”€â”€\u0026gt; S2 â”€â”€â”€â”€79Hzæ½œå‘é‡â”€â”€â”€â”€\u0026gt; S1 â”€â”€â”€â”€200HzåŠ¨ä½œâ”€â”€â”€â”€\u0026gt;æ‰§è¡Œå™¨\nObservationï¼ˆcommand + state + combind_img_tokenï¼‰â”€â”€â”€â”€â”€20Hzè§‚æµ‹ä¿¡æ¯â”€â”€â”€â”€\u0026gt; S1\nä¼ è¾“å¸¦å®½ æœªæåŠ\nç‰¹è‰² å®˜æ–¹è§‚ç‚¹ï¼š\nå…¨èº«æ§åˆ¶ï¼šå®ƒæ˜¯å†å²ä¸Šç¬¬ä¸€ä¸ªç±»äººæœºå™¨äººä¸ŠåŠèº«çš„é«˜é€Ÿè¿ç»­æ§åˆ¶ VLA æ¨¡å‹ï¼Œè¦†ç›–æ‰‹è…•ã€èº¯å¹²ã€å¤´éƒ¨å’Œå•ä¸ªæ‰‹æŒ‡ï¼› å¤šæœºå™¨äººåä½œï¼šå¯ä»¥ä¸¤å°æœºå™¨äººç”¨åŒæ ·çš„æ¨¡å‹æ§åˆ¶åä½œï¼Œå®Œæˆå‰æ‰€æœªè§çš„ä»»åŠ¡ï¼› æŠ“å–ä»»ä½•ç‰©å“ï¼šå¯ä»¥æ¡èµ·ä»»ä½•å°å‹ç‰©ä½“ï¼ŒåŒ…æ‹¬æ•°åƒç§å®ƒä»¬ä»æœªé‡åˆ°è¿‡çš„ç‰©å“ï¼Œåªéœ€éµå¾ªè‡ªç„¶è¯­è¨€æŒ‡ä»¤å³å¯ï¼› å•ä¸€ç¥ç»ç½‘ç»œï¼šHelix ä½¿ç”¨ä¸€ç»„ç¥ç»ç½‘ç»œæƒé‡æ¥å­¦ä¹ æ‰€æœ‰è¡Œä¸ºï¼Œå¦‚æŠ“å–å’Œæ”¾ç½®ç‰©å“ã€ä½¿ç”¨æŠ½å±‰å’Œå†°ç®±ã€ä»¥åŠè·¨æœºå™¨äººäº¤äº’ï¼Œè€Œæ— éœ€ä»»ä½•ä»»åŠ¡ç‰¹å®šçš„å¾®è°ƒï¼› æœ¬åœ°åŒ–ï¼šHelix æ˜¯å²ä¸Šç¬¬ä¸€ä¸ªåœ¨æ¿ç«¯ GPU è¿è¡Œçš„æœºå™¨äºº VLA æ¨¡å‹ï¼Œå·²ç»å…·å¤‡äº†å•†ä¸šåŒ–è½åœ°èƒ½åŠ›ã€‚ æ‰©å±•åˆ°å®¶ç”¨åœºæ™¯æˆæœ¬ä½ï¼šç›¸æ¯”äºä¼ ç»Ÿçš„ä¾æ®å•ä¸ªä»»åŠ¡ç”±æœºå™¨äººä¸“å®¶å®šåˆ¶åŒ–çš„æ§åˆ¶å’Œéœ€è¦é‡‡é›†å¤§é‡æ•°æ®çš„æ¨¡ä»¿å­¦ä¹ æ§åˆ¶ï¼Œå€ŸåŠ©VLMæ¨¡å‹å®ç°å¼ºå¤§æ³›åŒ–èƒ½åŠ›çš„ç«¯åˆ°ç«¯æ¨¡å‹æ›´æœ‰ä¼˜åŠ¿ é‡å­ä½è§‚ç‚¹\nç©ºé—´æ„ŸçŸ¥ï¼šå¤šç›¸æœºå®ç°éšå¼ç«‹ä½“è§†è§‰ä¸å¤šå°ºåº¦è§†è§‰è¡¨ç¤ºï¼Œå¢å¼ºäº†3Dç©ºé—´æ„ŸçŸ¥å’Œåœºæ™¯ç†è§£ç²¾åº¦ æ‰§è¡Œé€Ÿåº¦ä¸Šé™é«˜ï¼šåœ¨ç‰©æµåœºæ™¯çš„å¾®è°ƒåº”ç”¨ä¸­ä½¿ç”¨ç®€å•çš„test-timeåŠ é€ŸæŠ€æœ¯ï¼ˆåŒæ ·çš„waypointä»¥æ›´çŸ­çš„æ—¶é—´é—´éš”æ‰§è¡Œï¼‰ï¼Œä¿æŒé«˜æˆåŠŸç‡çš„åŒæ—¶å®ç°äº†æ›´å¿«çš„æ‰§è¡Œé€Ÿåº¦ã€‚ å¾®è°ƒæˆæœ¬ä½ï¼šä»…ç”¨8å°æ—¶ç²¾å¿ƒæŒ‘é€‰çš„æ•°æ®å°±èƒ½è®­ç»ƒå‡ºä¸€ä¸ªçµæ´»ä¸”é€‚åº”æ€§å¼ºçš„ç­–ç•¥ã€‚ å¼•å…¥è§†è§‰è‡ªæ ¡å‡†æ¨¡å‹ï¼šè¯¥æ¨¡å‹å¯ä»¥è®©æ¯ä¸ªæœºå™¨äººé€šè¿‡è‡ªèº«çš„è§†è§‰è¾“å…¥æ¥è‡ªæˆ‘æ ¡å‡†ï¼Œä¼°ç®—å‡ºæœºæ¢°è‡‚æœ«ç«¯çš„ç²¾ç¡®ä½ç½®å’Œå§¿æ€ï¼Œæé«˜è·¨æœºå™¨äººå®ä¾‹çš„æ³›åŒ–èƒ½åŠ›ã€‚ å­˜åœ¨è‡ªçº æ­£èƒ½åŠ›ï¼šè®­ç»ƒè¿‡ç¨‹ä¸­ï¼ŒFigureæ’é™¤äº†é‚£äº›è¾ƒæ…¢çš„ã€é—æ¼çš„æˆ–å¤±è´¥çš„æ¡ˆä¾‹ï¼Œä¸è¿‡ç‰¹æ„ä¿ç•™äº†åŒ…å«çº æ­£è¡Œä¸ºçš„æ¡ˆä¾‹ã€‚ é»˜è®¤äº¤äº’æ–¹å¼ä¸ºè¯­éŸ³äº¤äº’ ä¸ªäººåˆ¤æ–­ï¼š\né‡‡ç”¨ä¸ƒè‡ªç”±åº¦å†—ä½™æœºæ¢°è‡‚ï¼Œå·¥ä½œç©ºé—´æ›´å¤§ï¼Œç”±äºæ˜¯ç«¯åˆ°ç«¯çš„æ¨¡å‹ï¼Œä¸å­˜åœ¨FK/IKï¼Œå¤šä¸€ä¸ªè‡ªç”±åº¦å¯¹æ¨¡å‹æ¥è¯´åŒºåˆ«ä¸å¤§ï¼Œä½†æ•ˆæœä¼šå¥½å¾ˆå¤š æš‚ä¸èƒ½å®ç°è·¨æ„å‹çš„æ³›åŒ–èƒ½åŠ›ï¼Œä½†æ˜¯é’ˆå¯¹ä¸åŒçš„æ‰§è¡Œå™¨å’Œæœºå™¨äººæ„å‹ï¼Œä¸éœ€è¦æ”¹å˜æ¨¡å‹æ¶æ„ï¼Œåªéœ€è¦æ”¹å˜è¾“å‡ºå‚æ•°çš„æ•°é‡é‡æ–°é‡‡é›†æ•°æ®è®­ç»ƒæ¨¡å‹ ","date":"2025-03-25T06:34:20.467Z","image":"https://RoboticsChen.github.io/articles/figure-ai-helix-system-paper-reading/assets/image_hu_745518e71581943d.png","permalink":"https://RoboticsChen.github.io/articles/figure-ai-helix-system-paper-reading/","title":"Figure AI Helix System è®ºæ–‡æ€»ç»“"},{"content":"å®‰è£…ä¾èµ– perfï¼šé€šå¸¸å·²ç»å®‰è£…åœ¨å¤§å¤šæ•° Linux ç³»ç»Ÿä¸­ã€‚\n1 sudo apt-get install linux-tools-common linux-tools-generic Flamegraphï¼šç”± Brendan Gregg åˆ›å»ºçš„å·¥å…·é›†ï¼Œç”¨äºç”Ÿæˆç«ç„°å›¾ã€‚\n1 2 3 4 5 git clone https://github.com/brendangregg/Flamegraph.git # åœ¨åˆé€‚çš„ä½ç½®ä¿å­˜è„šæœ¬ cd Flamegraph sudo chmod +x *.pl echo \u0026#39;export PATH=\u0026#34;$PATH\u0026#34;:\u0026#39;$(pwd) \u0026gt;\u0026gt; ~/.bashrc # æ·»åŠ ç¯å¢ƒå˜é‡ source ~/.bashrc perfä½¿ç”¨æ•™ç¨‹ ä½¿ç”¨ perf å·¥å…·è¿›è¡Œæ€§èƒ½é‡‡æ ·ï¼Œ Ctrl+Cç»“æŸã€‚ 1 2 3 4 sudo sysctl -w kernel.kptr_restrict=0 # æš‚æ—¶å…è®¸å¯¹å†…æ ¸ç¬¦å·çš„è®¿é—® sudo sysctl -w kernel.perf_event_paranoid=-1 perf record -F 99 -a -g -- ./my_program F 99 è®¾ç½®é‡‡æ ·é¢‘ç‡ä¸ºæ¯ç§’ 99 æ¬¡ã€‚ a è¡¨ç¤ºå¯¹ç³»ç»Ÿä¸­çš„æ‰€æœ‰ CPU è¿›è¡Œé‡‡æ ·ã€‚ g è¡¨ç¤ºå¯ç”¨è°ƒç”¨å›¾ï¼ˆcall graphï¼‰æ”¶é›†ã€‚\nå°†è¿™äº›æ•°æ®è½¬æ¢ä¸ºç«ç„°å›¾æ ¼å¼,å†è½¬åŒ–ä¸ºæŠ˜å æ ¼å¼ï¼š 1 perf script \u0026gt; out.perf è½¬åˆ° Flamegraph çš„ç›®å½•ï¼Œå°† out.perf ä¸­çš„æ€§èƒ½æ•°æ®è½¬æ¢ä¸ºæŠ˜å æ ¼å¼ï¼Œå¹¶è¾“å‡ºåˆ° out.folded æ–‡ä»¶ã€‚ 1 ./stackcollapse-perf.pl out.perf \u0026gt; out.folded ç”Ÿæˆç«ç„°å›¾ï¼š 1 ./flamegraph.pl out.folded \u0026gt; flamegraph.svg å°†ç«ç„°å›¾æ‹–æ‹½åˆ°æµè§ˆå™¨å³å¯æŸ¥çœ‹ ä¸€é”®perfåˆ†æè„šæœ¬ å±•å¼€å¤åˆ¶ä¿å­˜ä¸º`perf_it.sh` âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #!/bin/bash # ç¡®ä¿ä¼ å…¥çš„å‘½ä»¤å‚æ•° if [ -z \u0026#34;$1\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;command_to_profile\u0026gt;\u0026#34; exit 1 fi # æš‚æ—¶å…è®¸å¯¹å†…æ ¸ç¬¦å·çš„è®¿é—® sudo sysctl -w kernel.kptr_restrict=0 sudo sysctl -w kernel.perf_event_paranoid=-1 # è®¾ç½®ä¿¡å·å¤„ç†ï¼šæ•è· Ctrl+C åç»§ç»­æ‰§è¡Œ cleanup() { if [ -f \u0026#34;perf.data\u0026#34; ]; then echo -e \u0026#34;\\næ•è·åˆ°ä¸­æ–­ä¿¡å·ï¼Œæ­£åœ¨ç”Ÿæˆç«ç„°å›¾...\u0026#34; generate_flamegraph else echo -e \u0026#34;\\næ•è·åˆ°ä¸­æ–­ä¿¡å·ï¼Œä½†æœªç”Ÿæˆ perf æ•°æ®ã€‚\u0026#34; fi exit 0 } generate_flamegraph() { # ç”Ÿæˆæ—¶é—´æˆ³ç›®å½• export tmp_time=$(date +\u0026#34;%Y%m%d_%H%M%S\u0026#34;) export tmp_dir=\u0026#34;flame_$tmp_time\u0026#34; mkdir -p \u0026#34;$tmp_dir\u0026#34; # ç§»åŠ¨ perf.data åˆ°ç›®æ ‡ç›®å½• mv perf.data \u0026#34;$tmp_dir/\u0026#34; || { echo \u0026#34;é”™è¯¯: æœªæ‰¾åˆ° perf.data æ–‡ä»¶\u0026#34; exit 1 } cd \u0026#34;$tmp_dir\u0026#34; || exit 1 # ç”Ÿæˆ perf æ•°æ® echo \u0026#34;æ­£åœ¨å¤„ç† perf æ•°æ®...\u0026#34; perf script \u0026gt; \u0026#34;$tmp_time.perf\u0026#34; || { echo \u0026#34;é”™è¯¯: perf script æ‰§è¡Œå¤±è´¥\u0026#34; exit 1 } # ç”ŸæˆæŠ˜å æ•°æ® stackcollapse-perf.pl \u0026#34;$tmp_time.perf\u0026#34; \u0026gt; \u0026#34;$tmp_time.folded\u0026#34; || { echo \u0026#34;é”™è¯¯: stackcollapse-perf.pl æ‰§è¡Œå¤±è´¥\u0026#34; exit 1 } # ç”Ÿæˆç«ç„°å›¾ flamegraph.pl \u0026#34;$tmp_time.folded\u0026#34; \u0026gt; \u0026#34;flamegraph_$tmp_time.svg\u0026#34; echo \u0026#34;ğŸ”¥ ç«ç„°å›¾ç”Ÿæˆå®Œæ¯•ï¼š$PWD/flamegraph_$tmp_time.svg\u0026#34; } # æ³¨å†Œä¿¡å·å¤„ç† trap cleanup SIGINT SIGTERM # è¿è¡Œ perf record å¹¶æ£€æŸ¥é€€å‡ºçŠ¶æ€ echo \u0026#34;å¼€å§‹æ€§èƒ½é‡‡é›† (æŒ‰ Ctrl+C åœæ­¢)...\u0026#34; if perf record -F 99 -a -g -- \u0026#34;$@\u0026#34;; then # ä»…å½“ perf record æˆåŠŸæ—¶ç”Ÿæˆç«ç„°å›¾ generate_flamegraph else echo \u0026#34;é”™è¯¯: ç›®æ ‡å‘½ä»¤æ‰§è¡Œå¤±è´¥ï¼Œè·³è¿‡ç«ç„°å›¾ç”Ÿæˆ\u0026#34; rm -f perf.data # æ¸…ç†å¯èƒ½çš„æ— æ•ˆæ•°æ® exit 1 fi ç”¨æ³•ï¼š\n1 ./perf_it ./my_program \u0026lt;args...\u0026gt; ","date":"2025-03-14T01:40:52.569Z","image":"https://RoboticsChen.github.io/articles/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/image_hu_b8d08c7084d41963.png","permalink":"https://RoboticsChen.github.io/articles/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"perfæ€§èƒ½åˆ†æå·¥å…·çš„ä½¿ç”¨"},{"content":"0. åŸç†ä»‹ç» è¯¥æ–¹æ¡ˆå…ˆé€šè¿‡xclipè·å–ç”¨æˆ·é€‰ä¸­çš„æ–‡æœ¬å†…å®¹ï¼Œå¯¹æ–‡æœ¬è¿›è¡Œæ¸…ç†ï¼ˆç§»é™¤éšè—å­—ç¬¦,htmlæ ‡ç­¾,æ¢è¡Œç¬¦ï¼‰ï¼Œç„¶åé€šè¿‡è°ƒç”¨ç¿»è¯‘ APIï¼ˆå¦‚è°·æ­Œç¿»è¯‘æˆ–å…¶ä»–æœåŠ¡ï¼‰å°†æ–‡æœ¬ç¿»è¯‘ä¸ºç›®æ ‡è¯­è¨€ï¼Œæœ€åä½¿ç”¨ç³»ç»Ÿé€šçŸ¥å·¥å…·ï¼ˆnotify-sendï¼‰å°†ç¿»è¯‘ç»“æœä»¥é€šçŸ¥çš„å½¢å¼æ˜¾ç¤ºç»™ç”¨æˆ·ã€‚\n1. å®‰è£…ä¾èµ– 1 sudo apt install xcilp jq xcilp ç”¨äºè·å–å‰ªè´´æ¿å†…å®¹ jq ç”¨äºå¯¹å­—ç¬¦ä¸²è¿›è¡Œ URL ç¼–ç ï¼ˆç™¾åˆ†å·ç¼–ç ï¼‰\n2. ç¼–å†™è„šæœ¬ åœ¨/optç›®å½•ä¸‹æ–°å»ºä¸€ä¸ªåä¸ºmy_translate.shçš„è„šæœ¬æ–‡ä»¶\n1 sudo nano /opt/my_translate.sh æ·»åŠ ä»¥ä¸‹å†…å®¹å¹¶ä¿å­˜é€€å‡ºï¼š\nç‚¹å‡»å±•å¼€ âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #!/bin/bash # ä»å‰ªè´´æ¿è·å–é€‰ä¸­çš„æ–‡å­— selected_text=$(xclip -o) clean_text=$(echo \u0026#34;$selected_text\u0026#34; | sed \u0026#39;s/\u0026lt;[^\u0026gt;]*\u0026gt;//g\u0026#39; | tr -d \u0026#39;\\n\\r\u0026#39; | tr -d \u0026#39;\\t\u0026#39; | tr -s \u0026#39; \u0026#39;) echo $clean_text # æ£€æŸ¥ç›®æ ‡è¯­è¨€å‚æ•° target_language=\u0026#34;$1\u0026#34; # è°·æ­Œç¿»è¯‘APIçš„URL API_URL=\u0026#34;https://translate.googleapis.com/translate_a/single?client=gtx\u0026amp;sl=auto\u0026amp;tl=$target_language\u0026amp;dt=t\u0026amp;q=\u0026#34; query=$(echo -n \u0026#34;$clean_text\u0026#34; | jq -sRr @uri) # è°ƒç”¨Google Translate API response=$(curl -sL \u0026#34;${API_URL}${query}\u0026#34;) ## just for debug #echo \u0026#34;å®Œæ•´è¯·æ±‚ URL: ${API_URL}${query}\u0026#34; \u0026gt;\u0026gt; debug_log.txt #echo \u0026#34;API å“åº”: $response\u0026#34; \u0026gt;\u0026gt; debug_log.txt # æå–ç¿»è¯‘ç»“æœ translation=$(echo $response | awk -F\u0026#39;\u0026#34;\u0026#39; \u0026#39;{print $2}\u0026#39;) echo $translation # å‘é€é€šçŸ¥ notify-send \u0026#34;Translate Rerult ($target_language): \u0026#34; \u0026#34;$translation\u0026#34; æ·»åŠ è¿è¡Œæƒé™\n1 sudo chmod +x /opt/my_translate.sh 3.å¿«æ·é”®è®¾ç½® åœ¨è®¾ç½®/é”®ç›˜/é”®ç›˜å¿«æ·é”®ä¸­æ·»åŠ ä¸¤ä¸ªè‡ªå®šä¹‰å¿«æ·é”®(en-\u0026gt;zh, zh-\u0026gt;en)ï¼š\næ³¨æ„æ ¹æ®è„šæœ¬åç§°å¯¹åº”ä¿®æ”¹å‘½ä»¤\n","date":"2024-12-01T05:17:56.756Z","image":"https://RoboticsChen.github.io/articles/linux-ubuntu-wayland-google-translate/translate_hu_39d4c8b4dc6de913.png","permalink":"https://RoboticsChen.github.io/articles/linux-ubuntu-wayland-google-translate/","title":"Linux åˆ’è¯è°·æ­Œç¿»è¯‘è§£å†³æ–¹æ¡ˆ"},{"content":"ç›¸æœºæˆåƒä¸ISP ç›¸æœºæˆåƒ CCD vs CMOS CCDï¼šå…¨ç§°Charge Coupled Deviceï¼Œå³ç”µè·è€¦åˆå™¨ä»¶ CMOSï¼šå…¨ç§°Complementary Metal Oxide Semiconductorï¼Œå³äº’è¡¥é‡‘å±æ°§åŒ–ç‰©åŠå¯¼ä½“ è¿™ä¸¤ç§ä¼ æ„Ÿå™¨éƒ½ç”±å¤šä¸ªå…‰ç”µäºŒæç®¡ç»„æˆçš„é˜µåˆ—ï¼Œæ¯ä¸ªå…‰ç”µäºŒæç®¡çš„ä½œç”¨æ˜¯å°†æ¥æ”¶åˆ°çš„å…‰ä¿¡å·è½¬åŒ–ä¸ºç”µè·ã€‚ä¸¤è€…çš„åŸºæœ¬å·¥ä½œåŸç†ç›¸ä¼¼ï¼Œä¼ æ„Ÿå™¨æ¥æ”¶å…‰ä¿¡å·å¹¶é€šè¿‡ä¸€å®šæ—¶é—´çš„ç”µè·ç§¯ç´¯å®ç°æ›å…‰ï¼Œè¿›è€Œè·å¾—æ¯ä¸ªåƒç´ çš„å…‰å¼ºåº¦æ•°æ®ã€‚æœ€åï¼Œè¿™äº›ç”µè·ç»æ¨¡æ•°è½¬æ¢è¢«è½¬æ¢ä¸ºç”µå‹å¹¶ç»è¿‡æ”¾å¤§å¤„ç†ï¼Œæœ€ç»ˆç”ŸæˆåŸå§‹çš„RAWå›¾åƒæ•°æ®ã€‚\nåœ¨å…·ä½“çš„å®ç°æ–¹å¼ä¸Šï¼Œä¸¤è€…æœ‰ä¸€å®šçš„åŒºåˆ«ï¼š\nCCDï¼šæ¯ä¸ªåƒç´ ç‚¹çš„ç”µè·ä¼šè¢«ä¼ è¾“åˆ°ä¸€ä¸ªå•ç‹¬çš„è¾“å‡ºèŠ‚ç‚¹ï¼Œé€šè¿‡è¿™ä¸€èŠ‚ç‚¹å°†ç”µè·è½¬åŒ–ä¸ºç”µå‹ä¿¡å·ï¼Œå³ä¸€è¡Œè¡Œè¯»å‡ºã€‚è¿™ç§æ–¹å¼æœ‰åŠ©äºå®ç°è¾ƒä½çš„å™ªå£°å’Œè¾ƒé«˜çš„å›¾åƒè´¨é‡ï¼Œä½†ç”±äºä¼ è¾“è¿‡ç¨‹ä¸­éœ€è¦å¤§é‡çš„ç”µå­å…ƒä»¶å’Œå¤æ‚çš„ç”µè·¯è®¾è®¡ï¼ŒCCDä¼ æ„Ÿå™¨çš„åŠŸè€—è¾ƒé«˜ï¼Œä¸”è¯»å‡ºé€Ÿåº¦è¾ƒæ…¢ã€‚ CMOSï¼šæ¯ä¸ªåƒç´ ç‚¹éƒ½å…·æœ‰ä¸€ä¸ªç‹¬ç«‹çš„æ”¾å¤§å™¨ï¼Œèƒ½å¤Ÿåœ¨ä¼ æ„Ÿå™¨å†…ç›´æ¥å°†ç”µè·è½¬åŒ–ä¸ºç”µå‹ä¿¡å·å¹¶è¿›è¡Œæ”¾å¤§å¤„ç†ã€‚è¿™ç§æ–¹å¼ä½¿å¾—æ¯ä¸ªåƒç´ çš„ç”µè·è½¬æ¢è¿‡ç¨‹ç›¸å¯¹ç‹¬ç«‹ï¼Œèƒ½æ›´å¿«é€Ÿåœ°è¯»å–å›¾åƒæ•°æ®ï¼Œé™ä½åŠŸè€—ï¼Œä½†åœ¨ä½å…‰ç…§ç¯å¢ƒä¸‹å¯èƒ½ä¼šäº§ç”Ÿè¾ƒå¤šå™ªå£°ã€‚ æ€»çš„æ¥çœ‹ï¼ŒCMOSä¼ æ„Ÿå™¨ç›¸æ¯”äºCCDä¼ æ„Ÿå™¨ï¼Œå·¥è‰ºç®€å•ã€æˆæœ¬æ›´ä½ï¼Œéšç€CMOSæŠ€æœ¯çš„ä¸æ–­è¿›æ­¥ï¼Œå°¤å…¶æ˜¯åœ¨é™ä½å™ªå£°ã€æé«˜ä½å…‰ç…§æ€§èƒ½å’Œå¢å¼ºå›¾åƒè´¨é‡æ–¹é¢çš„æå‡ï¼ŒCMOSä¼ æ„Ÿå™¨å·²ç»é€æ¸å–ä»£äº†ä¼ ç»Ÿçš„CCDä¼ æ„Ÿå™¨ï¼Œæˆä¸ºä¸»æµé€‰æ‹©ã€‚å½“ä»ŠCCDä¼ æ„Ÿå™¨çš„åº”ç”¨ä¸»è¦å±€é™äºä¸€äº›å¯¹å›¾åƒè´¨é‡è¦æ±‚æé«˜çš„ä¸“ä¸šé¢†åŸŸã€‚\nBayeré˜µåˆ—ä¸RAWå›¾åƒ 1.1èŠ‚ä¸­æåˆ°ï¼Œsensoré€šè¿‡å°†å…‰å¼ºä¿¡å·è½¬åŒ–ä¸ºç”µå‹ä¿¡å·ï¼Œä»è€Œå¾—åˆ°äº†RAWå›¾åƒï¼Œå› æ­¤ï¼Œå¦‚æœä¸åŠ ä»»ä½•å¤„ç†ï¼Œå¾—åˆ°çš„rawå›¾å°†æ˜¯åªæœ‰äº®åº¦çš„é»‘ç™½å›¾åƒã€‚\nä¸ºäº†åˆæˆå½©è‰²å›¾åƒï¼Œåˆ™éœ€è¦å¾—åˆ°æ¯ä¸€ä¸ªåƒç´ ç‚¹å¤„çš„RGBä¸‰é€šé“çš„äº®åº¦å€¼ã€‚è¦è·å¾—æŸä¸ªé€šé“çš„äº®åº¦å€¼ï¼Œå¯ä»¥åœ¨å…‰ç”µäºŒæç®¡å‰åŠ ä¸Šåªå…è®¸çº¢/ç»¿/è“è‰²å…‰é€šè¿‡çš„æ»¤å…‰ç‰‡ã€‚äºæ˜¯æˆ‘ä»¬å¯ä»¥é‡‡ç”¨è¿™æ ·ä¸€ç§æ’åˆ—æ–¹å¼ï¼Œå››ä¸ªæ»¤å…‰ç‰‡ä¾æ¬¡æŒ‰Rã€Gã€Gã€Bæ’åˆ—ã€‚ä¸ºä»€ä¹ˆæ˜¯ä¸¤ä¸ªç»¿è‰²å‘¢ï¼Œå› ä¸ºäººçœ¼å¯¹ç»¿è‰²æ›´ä¸ºæ•æ„Ÿï¼Œæ‰€ä»¥è¿™é‡Œä½¿ç”¨ä¸¤ä¸ªç»¿è‰²æ¥å¢å¼ºç»¿è‰²çš„è§£æåŠ›ã€‚è¿™ç§æ’åˆ—æ–¹å¼åˆç§°Bayeré˜µåˆ—ï¼ˆBayer Patternï¼‰ï¼Œäº1974ç”±æŸ¯è¾¾çš„å·¥ç¨‹å¸ˆBayeræå‡ºã€‚\né™¤äº†æœ€å¸¸ç”¨çš„Bayeré˜µåˆ—ï¼Œä¸€äº›å‚å•†ä¹Ÿé‡‡ç”¨äº†å…¶ä»–çš„æ’åˆ—æ–¹å¼ï¼Œå¦‚ç´¢å°¼çš„REGB(çº¢é’ç»¿è“)ï¼Œåä¸ºçš„RYYB(çº¢é»„é»„è“)ï¼Œå¯Œå£«çš„ä¹±ä¸ƒå…«ç³Ÿæ’åˆ—ï¼ˆbushi\nå¦‚æœæ­¤æ—¶ï¼Œæˆ‘ä»¬å°†è¿™äº›bayeræ’åˆ—çš„ç”µä¿¡å·è½¬æ¢æˆæ•°å­—ä¿¡å·ï¼Œå¹¶ä¿å­˜ä¸‹æ¥ï¼Œå°±å¯ä»¥å¾—åˆ°RAWå›¾åƒã€‚\næ­¤æ—¶çš„å›¾åƒä¾æ—§æ˜¯é»‘ç™½çš„ï¼Œå¹¶ä¸”å¦‚æœæ”¾å¤§å±€éƒ¨ï¼Œä¼šå‘ç°å›¾åƒä¼šå‘ˆç°é©¬èµ›å…‹ä¸€æ ·çš„æ•ˆæœï¼Œä¸ºäº†å¾—åˆ°æœ€ç»ˆçš„å›¾åƒï¼Œéœ€è¦å®Œæˆä¸€ç³»åˆ—å›¾åƒä¿¡å·å¤„ç†ï¼Œå³Image Signal Processing(ISP)ã€‚\nImage Signal Processï¼ˆISPï¼‰ åç‚¹æ ¡æ­£ï¼ˆDead Pixel Correction, DPCï¼‰ æ ¹æ®æ˜¯å¦ä¼šå‘ç”Ÿå˜åŒ–ï¼Œåç‚¹å¯ä»¥åˆ†ä¸ºé™æ€åç‚¹å’ŒåŠ¨æ€åç‚¹ã€‚\né™æ€åç‚¹ï¼šä¸éšç€æ—¶é—´ã€å¢ç›Šç­‰æ”¹å˜ï¼Œé€šå¸¸æ˜¯sensoråˆ¶é€ æ—¶å› å·¥è‰ºåŸå› äº§ç”Ÿçš„åç‚¹ã€‚ åŠ¨æ€åç‚¹ï¼šå› ä¸ºå¢ç›Šã€æ¸©åº¦ç­‰å¼•èµ·çš„åç‚¹ï¼Œä¼šéšç€æ—¶é—´å˜åŒ–è€Œæ”¹å˜ã€‚ åœ¨ ISP å¤„ç†é˜¶æ®µï¼Œéœ€è¦å¯¹å›¾åƒä¸­çš„åç‚¹è¿›è¡Œæ ¡æ­£ã€‚é™æ€åç‚¹é€šå¸¸åœ¨ä¼ æ„Ÿå™¨ç”Ÿäº§çº¿ä¸Šæ ‡å®šï¼Œå…¶ä½ç½®ä¼šè¢«è®°å½•åˆ° OTPï¼ˆOne Time Programmableï¼‰å­˜å‚¨å™¨ä¸­ï¼Œç”¨äºåç»­æ ¡æ­£ã€‚\nåŠ¨æ€åç‚¹çš„æ ¡æ­£åˆ™å‘ç”Ÿåœ¨é™æ€åç‚¹æ ¡æ­£å®Œæˆä¹‹åã€‚æ ¡æ­£è¿‡ç¨‹ä¸­ï¼Œé€šè¿‡é€ä¸€æ£€æŸ¥æ¯ä¸ªåƒç´ ç‚¹ä¸å…¶å‘¨å›´ä¸€å®šèŒƒå›´å†…çš„åƒç´ å€¼ï¼Œå¦‚æœå‘ç°æŸä¸ªåƒç´ çš„å€¼ä¸å‘¨å›´åƒç´ çš„å€¼å·®å¼‚è¶…è¿‡è®¾å®šé˜ˆå€¼ï¼Œåˆ™åˆ¤å®šä¸ºåç‚¹ã€‚å¯¹äºè¿™äº›åç‚¹ï¼Œé€šå¸¸ä½¿ç”¨åŒé€šé“å†…å‘¨å›´åƒç´ çš„å¹³å‡å€¼æ¥æ›¿ä»£è¿›è¡Œæ ¡æ­£ï¼Œä»è€Œæ¢å¤å›¾åƒçš„å®Œæ•´æ€§å’Œè´¨é‡ã€‚\nç¤ºä¾‹ä»£ç  âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 /** * @brief Performs dead pixel correction (DPC) on RAW image data by identifying * and correcting pixels that differ significantly from their neighbors. * * @param raw Reference to the input RAW image data. * @param thres Threshold value for detecting dead pixels. A pixel is * considered dead if it deviates from its neighboring pixels by more than this * threshold. * @param mode DPC correction mode. Options are: * - DPC_MODE_MEAN: Replaces the dead pixel value with the * average of its immediate neighbors. * - DPC_MODE_GRADIENT: Replaces the dead pixel based on the * smallest gradient among neighboring pixels. * - DPC_MODE_UNKNOWN: Throws an error if the mode is * unrecognized. * @param clip Maximum allowable pixel value after correction. Values * exceeding this are clipped. **/ void DPC(ImageRaw\u0026amp; raw, uint16_t thres, DPC_MODE mode, uint16_t clip) { ImageRaw* raw_pad = new ImageRaw(raw); raw_pad-\u0026gt;padding(2, PADDING_MODE_REFLECT); for (int y = 0; y \u0026lt; raw_pad-\u0026gt;getHeight() - 4; y++) { for (int x = 0; x \u0026lt; raw_pad-\u0026gt;getWidth() - 4; x++) { uint16_t p0, p1, p2, p3, p4, p5, p6, p7, p8; uint16_t dv, dh, ddl, ddr, minimal; p0 = raw_pad-\u0026gt;at(y + 2, x + 2); p1 = raw_pad-\u0026gt;at(y, x); p2 = raw_pad-\u0026gt;at(y, x + 2); p3 = raw_pad-\u0026gt;at(y, x + 4); p4 = raw_pad-\u0026gt;at(y + 2, x); p5 = raw_pad-\u0026gt;at(y + 2, x + 4); p6 = raw_pad-\u0026gt;at(y + 4, x); p7 = raw_pad-\u0026gt;at(y + 4, x + 2); p8 = raw_pad-\u0026gt;at(y + 4, x + 4); if ((ABS(p1 - p0) \u0026gt; thres) \u0026amp;\u0026amp; (ABS(p2 - p0) \u0026gt; thres) \u0026amp;\u0026amp; (ABS(p3 - p0) \u0026gt; thres) \u0026amp;\u0026amp; (ABS(p4 - p0) \u0026gt; thres) \u0026amp;\u0026amp; (ABS(p5 - p0) \u0026gt; thres) \u0026amp;\u0026amp; (ABS(p6 - p0) \u0026gt; thres) \u0026amp;\u0026amp; (ABS(p7 - p0) \u0026gt; thres) \u0026amp;\u0026amp; (ABS(p8 - p0) \u0026gt; thres)) { switch (mode) { case DPC_MODE_MEAN: p0 = (p2 + p4 + p5 + p7) / 4; break; case DPC_MODE_GRADIENT: dv\t= ABS(2 * p0 - p2 - p7); dh\t= ABS(2 * p0 - p4 - p5); ddl\t= ABS(2 * p0 - p1 - p8); ddr\t= ABS(2 * p0 - p3 - p6); minimal\t= MIN(MIN(MIN(dv, dh), ddl), ddr); if (minimal == dv)\tp0 = (p2 + p7 + 1) / 2; // Adding +1 here helps prevent rounding errors in integer division. else if (minimal == dh)\tp0 = (p4 + p5 + 1) / 2; else if (minimal == ddl)\tp0 = (p1 + p8 + 1) / 2; else\tp0 = (p3 + p6 + 1) / 2; break; case DPC_MODE_UNKNOWN: TRACE_DEBUG_LOG_ERROR(\u0026#34;Unknown DPC Mode:%s\\n\u0026#34;, mode); throw \u0026#34;Unknown DPC mode\u0026#34;; break; default: TRACE_DEBUG_LOG_ERROR(\u0026#34;Unknown DPC Mode:%s\\n\u0026#34;, mode); throw \u0026#34;Unknown DPC mode\u0026#34;; break; } raw.at(y, x) = p0; } } } raw.clip(0, clip); delete raw_pad; } æš—ç”µæµæ ¡æ­£ï¼ˆBlack level Correctionï¼ŒBLCï¼‰ æš—ç”µæµæ ¡æ­£åˆç§°â€œé»‘åº¦æ ¡æ­£â€ã€‚åœ¨ç›¸æœºå·¥ä½œè¿‡ç¨‹ä¸­ï¼Œå³ä½¿æ²¡æœ‰æ¥æ”¶åˆ°å…‰ä¿¡å·ï¼Œä¼ æ„Ÿå™¨ä¹Ÿä¼šç”±äºæŸäº›å› ç´ äº§ç”Ÿä¸€å®šçš„æš—ç”µæµï¼Œä»è€Œå¯¼è‡´è¾“å‡ºçš„ç”µå‹ä¿¡å·å­˜åœ¨åç§»ï¼Œå›¾åƒçš„â€œé»‘åº¦â€ä¸çœŸå®æƒ…å†µå­˜åœ¨å·®å¼‚ã€‚è¿™ä¸ªåç§»å€¼çš„æ¥æºæœ‰ä¸¤æ–¹é¢ï¼Œå…¶ä¸€æ˜¯æ¨¡æ•°è½¬æ¢åƒçš„å¢ç›Šï¼Œå…¶äºŒæ˜¯æ¸©åº¦ç­‰ç‰©ç†åŸå› å¯¼è‡´çš„ä¼ æ„Ÿå™¨åç§»ã€‚é»‘ç”µå¹³æ ¡æ­£æ¨¡å—å°±æ˜¯é€šè¿‡æ ‡å®šçš„æ–¹å¼ï¼Œç¡®å®šè¿™ä¸ªåç§»é‡çš„å…·ä½“å€¼ã€‚åç»­çš„ ISP å¤„ç†æ¨¡å—ï¼Œéœ€è¦å…ˆå‡æ‰è¯¥åç§»å€¼ï¼Œæ‰èƒ½ä¿è¯å›¾åƒçš„å‡†ç¡®æ€§ã€‚\næ¨¡æ‹Ÿä¿¡å·å¾ˆå¾®å¼±æ—¶ï¼Œæœ‰å¯èƒ½ä¸è¢« A/D è½¬æ¢å‡ºæ¥ï¼Œå¯¼è‡´å…‰çº¿å¾ˆæš—æ—¶ï¼Œå›¾åƒç»†èŠ‚ä¸¢å¤±ã€‚å› æ­¤ï¼ŒSesnor ä¼šåœ¨ A/D è½¬æ¢å‰ï¼Œç»™æ¨¡æ‹Ÿä¿¡å·ä¸€ä¸ªå›ºå®šçš„åç§»é‡ï¼Œä¿è¯è¾“å‡ºçš„æ•°å­—ä¿¡å·ä¿ç•™æ›´å¤šçš„å›¾åƒç»†èŠ‚ã€‚ é€šå¸¸çš„æ ¡æ­£æ–¹æ³•æ˜¯åœ¨ä¼ æ„Ÿå™¨å®Œå…¨é®å…‰çš„æƒ…å†µä¸‹æ•è·â€œæš—å¸§â€ã€‚ç„¶åè®°å½•æ¯ä¸ªåƒç´ çš„æ•°å­—è¾“å‡ºï¼Œè®¡ç®—è¯¥å›¾åƒçš„å¹³å‡å€¼ï¼ˆæœ‰æ—¶ä½¿ç”¨ä¸­å€¼ï¼‰ã€‚è¿™ä¸ªå¹³å‡å€¼æˆ–ä¸­å€¼è¡¨ç¤ºä¼ æ„Ÿå™¨çš„æ•´ä½“é»‘ç”µå¹³åç§»ã€‚æ¥ä¸‹æ¥ï¼Œå°†è¯¥å€¼ä»ä¼ æ„Ÿå™¨ç”Ÿæˆçš„å›¾åƒä¸­çš„æ¯ä¸ªåƒç´ å€¼ä¸­å‡å»ï¼Œä»¥æ ¡æ­£æš—ç”µæµå¼•èµ·çš„åç§»ï¼Œæ¢å¤å›¾åƒçš„çœŸå®äº®åº¦ã€‚\nç¤ºä¾‹ä»£ç  âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 /** * @brief Performs black level correction (BLC) on RAW image data based on the * specified Bayer pattern. * * @param raw Reference to the input RAW image data. * @param r Black level correction value for the red channel. * @param gr Black level correction value for the green channel (red * row). * @param gb Black level correction value for the green channel (blue * row). * @param b Black level correction value for the blue channel. * @param alpha Alpha coefficient for adjusting the green channel (red * row). * @param beta Beta coefficient for adjusting the green channel (blue * row). * @param bayer_pattern The Bayer pattern used in the RAW data (e.g., RGGB, * BGGR, GBRG, GRBG). * @param clip Maximum allowable pixel value after correction. Values * exceeding this are clipped. */ void BLC(ImageRaw\u0026amp; raw, uint16_t r, uint16_t gr, uint16_t gb, uint16_t b, float alpha, float beta, BAYER_PATTERN bayer_pattern, uint16_t clip) { switch (bayer_pattern) { case BAYER_PATTERN_RGGB: for (int y = 0; y \u0026lt; raw.getHeight(); y+=2) { for (int x = 0; x \u0026lt; raw.getWidth(); x+=2) { raw.at(y, x)\t+= r;\t// r raw.at(y + 1, x + 1)\t+= b;\t// b raw.at(y, x + 1)\t+= gr + alpha * raw.at(y, x);\t// gr raw.at(y + 1, x)\t+= gb + beta * raw.at(y + 1, x + 1);\t// gb } } break; case BAYER_PATTERN_BGGR: for (int y = 0; y \u0026lt; raw.getHeight(); y+=2) { for (int x = 0; x \u0026lt; raw.getWidth(); x+=2) { raw.at(y, x) += b; raw.at(y + 1, x + 1) += r; raw.at(y, x + 1) += gb + beta * raw.at(y, x); raw.at(y + 1, x) += gr + alpha * raw.at(y + 1, x + 1); } } break; case BAYER_PATTERN_GBRG: for (int y = 0; y \u0026lt; raw.getHeight(); y+= 2) { for (int x = 0; x \u0026lt; raw.getWidth(); x+= 2) { raw.at(y, x + 1) += b; raw.at(y + 1, x) += r; raw.at(y, x) += gb + beta * raw.at(y, x + 1); raw.at(y + 1, x + 1) += gr + alpha * raw.at(y + 1, x); } } break; case BAYER_PATTERN_GRBG: for (int y = 0; y \u0026lt; raw.getHeight(); y+= 2) { for (int x = 0; x \u0026lt; raw.getWidth(); x+= 2) { raw.at(y + 1, x) += b; raw.at(y, x + 1) += r; raw.at(y + 1, x + 1) += gb + beta * raw.at(y + 1, x);\traw.at(y, x) += gr + alpha * raw.at(y, x + 1); } } break; case BAYER_PATTERN_UNKNOWN: default: TRACE_DEBUG_LOG_ERROR(\u0026#34;Unknown Bayer Pattern:%s\\n\u0026#34;, bayer_pattern); throw \u0026#34;Unknown bayer pattern\u0026#34;; break; } raw.clip(0, clip); } é•œå¤´é˜´å½±æ ¡æ­£ï¼ˆLens Shading Correctionï¼ŒLSCï¼‰ Lens Shading æ˜¯ç›¸æœºæˆåƒè¿‡ç¨‹ä¸­ä¸€ç§ç”±é•œå¤´ä¸å›¾åƒä¼ æ„Ÿå™¨çš„å…‰å­¦ç‰¹æ€§å¼•èµ·çš„ç°è±¡ã€‚å…·ä½“è¡¨ç°ä¸ºå›¾åƒäº®åº¦å’Œé¢œè‰²åœ¨è§†åœºï¼ˆField of Viewï¼ŒFOVï¼‰ä¸­çš„åˆ†å¸ƒä¸å‡åŒ€ï¼Œé€šå¸¸æ˜¯å›¾åƒä¸­å¿ƒäº®åº¦è¾ƒé«˜ï¼Œè€Œè¾¹ç¼˜äº®åº¦è¾ƒä½ï¼Œå¹¶å¯èƒ½ä¼´éšé¢œè‰²åç§»ã€‚å®ƒæ˜¯æš—è§’ç°è±¡ï¼ˆVignettingï¼‰çš„æ‰©å±•ï¼ŒåŒ…å«äº†äº®åº¦ï¼ˆLuma Shadingï¼‰å’Œè‰²å½©ï¼ˆChroma Shadingï¼‰çš„ä¸å‡åŒ€æ€§ã€‚\näº®åº¦ï¼ˆLumaï¼‰é˜´å½± Luma Shading ä¹Ÿè¢«ç§°ä¸ºæ¸æ™•ï¼ˆVignettingï¼‰ï¼Œç”±äºé€é•œç»„çš„å…‰å­¦ç‰¹æ€§ï¼Œå…¥å°„å…‰åç¦»å…‰è½´è§’åº¦è¾ƒå¤§æ—¶ï¼Œéƒ¨åˆ†å…‰å°±ä¼šå—å…‰é˜‘çš„å½±å“è€Œæ— æ³•åœ¨æ„Ÿå…‰å¹³é¢ä¸Šæˆåƒï¼Œä»è€Œå¯¼è‡´è¶Šé è¿‘è¾¹ç¼˜çš„åƒç´ äº®åº¦è¶Šä½ã€‚\næ­¤å¤–,å¯¹äºFSIå·¥è‰ºçš„sensorï¼ŒLuma shadingçš„ä¸»è¦æˆå› è¿˜åŒ…æ‹¬è¾¹ç¼˜åƒç´ ç„¦ç‚¹é”™ä½ï¼Œè§£å†³è¿™ä¸ªé—®é¢˜å¯ä»¥é€šè¿‡è¾¹ç¼˜å¾®é€é•œçš„åç§»æ¥ä¿®æ­£ï¼Œå³ä»ä¸­å¿ƒåƒç´ å¼€å§‹ï¼Œå¾®é€é•œçš„ç›´å¾„éƒ½ç•¥å°äºæˆåƒé¢ï¼Œè¿™æ ·è¶Šæ¥è¿‘è¾¹ç¼˜ï¼Œå¾®é€é•œä¸æˆåƒé¢ä¹‹é—´çš„åç§»å°±è¶Šå¤§ï¼Œä»è€Œå¯ä»¥è¡¥å¿å…¥å°„å…‰çº¿è§’åº¦è¿‡å¤§å¯¼è‡´çš„ç„¦ç‚¹åç§»ï¼Œä½¿å¾®é€é•œçš„CRAå¢å¤§ï¼Œä»è€Œå…‰çº¿å¯ä»¥æ›´å¥½åœ°æ±‡èšåˆ°æ„Ÿå…‰å¹³é¢ä¸Šã€‚\næ‰©å±•é˜…è¯»ï¼š FSI vs BSI ã€ ä»€ä¹ˆæ˜¯CRA\nè‰²å½©ï¼ˆChromaï¼‰é˜´å½± Chroma Shadingæ˜¯Lens Shadingçš„ä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œä¸»è¦è¡¨ç°ä¸ºä»ä¸­å¿ƒå‘è¾¹ç¼˜çš„è‰²æ™•ã€‚\nChroma Shadingçš„æˆå› ï¼Œçœ‹äº†å¾ˆå¤šåšå®¢ä»¥åŠæ–‡ç« ï¼Œä¼—è¯´çº·çº­ï¼Œæ€»ç»“èµ·æ¥ä¸»è¦ä¸¤ä¸ªåŸå› ï¼š\nå¯¹ä¸åŒæ³¢é•¿çš„å…‰å…·æœ‰ä¸åŒçš„æŠ˜å°„ç‡ï¼Œå› æ­¤åœ¨æˆåƒæ—¶ä¸åŒè‰²å…‰çš„ç„¦å¹³é¢å¹¶ä¸é‡åˆï¼Œä»è€Œäº§ç”Ÿäº†è‰²å·®ã€‚ ç”±äºå¹²æ¶‰å‹çº¢å¤–æ»¤å…‰ç‰‡ï¼ˆIR-Filterï¼‰å¯¹ä¸åŒå…¥å°„è§’åº¦çš„çº¢å¤–å…‰çš„é˜»éš”æ•ˆæœä¸åŒï¼Œä»è€Œå¯¼è‡´éƒ¨åˆ†å¤§è§’åº¦å…¥å°„çš„è¿‘çº¢å¤–å…‰æ²¡æœ‰è¢«é˜»éš”ï¼Œä»è€Œäº§ç”Ÿäº†ä»ä¸­å¿ƒå‘è¾¹ç¼˜çš„è‰²æ™•ã€‚ æ ¡æ­£ç®—æ³• ç›®å‰å¸¸ç”¨çš„é•œå¤´é˜´å½±æ ¡æ­£ç®—æ³•æ˜¯å¢ç›Šæ³•ã€‚ç”±äºå­˜å‚¨æ¯ä¸ªåƒç´ ç‚¹çš„æ ¡æ­£ç³»æ•°ä¼šå ç”¨å¤§é‡å­˜å‚¨ç©ºé—´ï¼Œå®é™…å®ç°ä¸­é€šå¸¸å¯¹å›¾åƒè¿›è¡ŒnÃ—n ç½‘æ ¼åˆ’åˆ†ï¼ˆä¸€èˆ¬é€‰æ‹© 16Ã—16 çš„ç½‘æ ¼ï¼‰ï¼Œä»…å­˜å‚¨è¿™äº›ç½‘æ ¼ç‚¹å¤„çš„æ ¡æ­£ç³»æ•°ã€‚å¯¹äºç½‘æ ¼ä¹‹é—´çš„å…¶ä»–åƒç´ ç‚¹ï¼Œå…¶æ ¡æ­£ç³»æ•°é€šè¿‡å››æ¬¡ä½™å¼¦æ’å€¼è®¡ç®—å¾—åˆ°ã€‚\nå››æ¬¡ä½™å¼¦å®šå¾‹ï¼š$I_\\theta = I_0 \\cos^4 \\theta$ï¼Œå³å¯¹äºä¸€ä¸ªæˆåƒé•œå¤´ç³»ç»Ÿï¼Œç¦»å…‰è½´çš„åƒç´ äº®åº¦ä¼šéšç€ç¦»è½´è§†åœºè§’$\\theta$çš„å¢å¤§æŒ‰$\\cos^4\\theta$çš„æ¯”ä¾‹ä¸‹é™ã€‚è¿™ç§å…‰å­¦ç°è±¡æ˜¯é•œå¤´é˜´å½±æ•ˆåº”çš„ç†è®ºåŸºç¡€ï¼Œæ ¡æ­£æ—¶éœ€è¦é€šè¿‡æ’å€¼è®¡ç®—æ¥è¡¥å¿äº®åº¦ã€‚\nè€Œè¦å¾—åˆ°è¯¥nxnä¸ªæ ¼ç‚¹å¤„çš„æ ¡æ­£ç³»æ•°ï¼Œåœ¨å‡åŒ€å…‰æºä¸‹é‡‡é›†å‚è€ƒå›¾åƒï¼Œè®°å½•æ¯ä¸ªåƒç´ çš„å®é™…äº®åº¦å€¼ï¼Œå¹¶ä¸ç†æƒ³äº®åº¦è¿›è¡Œå¯¹æ¯”ï¼Œåè€…ä¸å‰è€…çš„æ¯”å€¼å³ä¸ºæ ¡æ­£ç³»æ•°ã€‚\n$$G(i,j)=\\frac{I_{\\mathrm{ideal}}(i,j)}{I_{\\mathrm{observed}}(i,j)}$$\nç¤ºä¾‹ä»£ç ï¼šLuma Shading Correction âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * @brief Performs lens shading correction (LSC) on RAW image data to compensate * for brightness falloff towards the edges. * * @param raw Reference to the input RAW image data. * @param intensity Intensity of the lens shading correction. Higher values * apply stronger correction. * @param minR Minimum radius (distance from the center) for applying * correction. If less than 0, defaults to 0. * @param maxR Maximum radius (distance from the center) for applying * correction. If less than 0, defaults to the distance from the center to the * farthest corner of the image. * @param clip Maximum allowable pixel value after correction. Values * exceeding this are clipped. */ void LSC(ImageRaw\u0026amp; raw, uint16_t intensity, int minR, int maxR, uint16_t clip) { if (minR \u0026lt; 0) minR = 0; if (maxR \u0026lt; 0) maxR = sqrt(pow(raw.getHeight() / 2, 2) + pow(raw.getWidth() / 2, 2)); for (int y = 0; y \u0026lt; raw.getHeight(); y++) { for (int x = 0; x \u0026lt; raw.getWidth(); x++) { int r = sqrt(pow((y - raw.getHeight() / 2), 2) + pow((x - raw.getWidth() / 2), 2)); float factor = (r - minR) / (maxR - minR); raw.at(y, x) = raw.at(y, x) * (1 + intensity * (factor + 0.5)); } } raw.clip(0, clip); } ç¤ºä¾‹ä»£ç ï¼šChroma Shading Correction âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 float __cnc(const char* is_color, float center, float avgG, float avgC1, float avgC2, float r_gain, float gr_gain, float gb_gain, float b_gain) { float dampFactor = 1.0; float signalGap = center - MAX(avgG, avgC2); if (strcmp(is_color, \u0026#34;r\u0026#34;) == 0) { if (r_gain \u0026lt;= 1.0) dampFactor = 1.0; else if (r_gain \u0026gt; 1.0 \u0026amp;\u0026amp; r_gain \u0026lt;= 1.2) dampFactor = 0.5; else if (r_gain \u0026gt; 1.2) dampFactor = 0.3; } if (strcmp(is_color, \u0026#34;b\u0026#34;) == 0) { if (b_gain \u0026lt;= 1.0) dampFactor = 1.0; else if (b_gain \u0026gt; 1.0 \u0026amp;\u0026amp; b_gain \u0026lt;= 1.2) dampFactor = 0.5; else if (b_gain \u0026gt; 1.2) dampFactor = 0.3; } float chromaCorrected = MAX(avgG, avgC2) + dampFactor * signalGap; float signalMeter = 0.299 * avgC2 + 0.587 * avgG + 0.144 * avgC1; if (strcmp(is_color, \u0026#34;r\u0026#34;) == 0) signalMeter = 0.299 * avgC1 + 0.587 * avgG + 0.144 * avgC2; else if (strcmp(is_color, \u0026#34;b\u0026#34;) == 0) signalMeter = 0.299 * avgC2 + 0.587 * avgG + 0.144 * avgC1; float fade1 = 0, fade2 = 0; if (signalMeter \u0026lt;= 30) fade1 = 1.0; else if (signalMeter \u0026gt; 30 \u0026amp;\u0026amp; signalMeter \u0026lt;= 50) fade1 = 0.9; else if (signalMeter \u0026gt; 50 \u0026amp;\u0026amp; signalMeter \u0026lt;= 70) fade1 = 0.8; else if (signalMeter \u0026gt; 70 \u0026amp;\u0026amp; signalMeter \u0026lt;= 100) fade1 = 0.7; else if (signalMeter \u0026gt; 100 \u0026amp;\u0026amp; signalMeter \u0026lt;= 150) fade1 = 0.6; else if (signalMeter \u0026gt; 150 \u0026amp;\u0026amp; signalMeter \u0026lt;= 200) fade1 = 0.3; else if (signalMeter \u0026gt; 200 \u0026amp;\u0026amp; signalMeter \u0026lt;= 250) fade1 = 0.1; else fade1 = 0; if (avgC1 \u0026lt;= 30) fade2 = 1.0; else if (avgC1 \u0026gt; 30 \u0026amp;\u0026amp; avgC1 \u0026lt;= 50) fade2 = 0.9; else if (avgC1 \u0026gt; 50 \u0026amp;\u0026amp; avgC1 \u0026lt;= 70) fade2 = 0.8; else if (avgC1 \u0026gt; 70 \u0026amp;\u0026amp; avgC1 \u0026lt;= 100) fade2 = 0.6; else if (avgC1 \u0026gt; 100 \u0026amp;\u0026amp; avgC1 \u0026lt;= 150) fade2 = 0.5; else if (avgC1 \u0026gt; 150 \u0026amp;\u0026amp; avgC1 \u0026lt;= 200) fade2 = 0.3; else fade2 = 0; float fadeTot = fade1 * fade2; return (1 - fadeTot) * center + fadeTot * chromaCorrected; } void __cnd(int y, int x, ImageRaw* img, float thres, int\u0026amp; is_noise, float\u0026amp; avgG, float\u0026amp; avgC1, float\u0026amp; avgC2) { avgG = 0, avgC1 = 0, avgC2 = 0; is_noise = 0; for (int i = y - 4; i \u0026lt; y + 4; i++) { for (int j = x - 4; j \u0026lt; x + 4; j++) { if ((i % 2 == 1) \u0026amp;\u0026amp; (j % 2 == 0))\tavgG = avgG + img-\u0026gt;at(i, j); else if ((i % 2 == 0) \u0026amp;\u0026amp; (j % 2 == 1))\tavgG = avgG + img-\u0026gt;at(i, j); else if ((i % 2 == 0) \u0026amp;\u0026amp; (j % 2 == 0))\tavgC1 = avgC1 + img-\u0026gt;at(i, j); else if ((i % 2 == 1) \u0026amp;\u0026amp; (j % 2 == 1))\tavgC2 = avgC2 + img-\u0026gt;at(i, j); } } avgG = avgG / 40; avgC1 = avgC1 / 25; avgC2 = avgC2 / 16; float center = img-\u0026gt;at(y, x); if ((center \u0026gt; avgG + thres) \u0026amp;\u0026amp; (center \u0026gt; avgC2 + thres)) { if ((avgC1 \u0026gt; avgG + thres) \u0026amp;\u0026amp; (avgC1 \u0026gt; avgC2 + thres)) { is_noise = 1; } else { is_noise = 0; } } else { is_noise = 0; } } float __cnf(const char* is_color, int y, int x, ImageRaw* img, float thres, float r_gain, float gr_gain, float gb_gain, float b_gain) { int is_noise; float avgG, avgC1, avgC2; __cnd(y, x, img, thres, is_noise, avgG, avgC1, avgC2); float pix_out; if (is_noise == 1) { pix_out = __cnc(is_color, img-\u0026gt;at(y, x), avgG, avgC1, avgC2, r_gain, gr_gain, gb_gain, b_gain); } else { pix_out = img-\u0026gt;at(y, x); } return pix_out; } void CNF(ImageRaw\u0026amp; img, BAYER_PATTERN bayer_pattern, float threshold, float r_gain, float gr_gain, float gb_gain, float b_gain, uint16_t clip) { ImageRaw* img_pad = new ImageRaw(img); img_pad-\u0026gt;padding(4, PADDING_MODE_REFLECT); uint16_t r, gr, gb, b; for (int y = 0; y \u0026lt; img_pad-\u0026gt;getHeight() - 8 - 1; y += 2) { for (int x = 0; x \u0026lt; img_pad-\u0026gt;getWidth() - 8 - 1; x += 2) { switch (bayer_pattern) { case BAYER_PATTERN_RGGB: r = img_pad-\u0026gt;at(y + 4, x + 4); gr = img_pad-\u0026gt;at(y + 4, x + 5); gb = img_pad-\u0026gt;at(y + 5, x + 4); b = img_pad-\u0026gt;at(y + 5, x + 5); img.at(y, x) = __cnf(\u0026#34;r\u0026#34;, y + 4, x + 4, img_pad, threshold, r_gain, gr_gain, gb_gain, b_gain); img.at(y, x + 1) = gr; img.at(y + 1, x) = gb; img.at(y + 1, x + 1) = __cnf(\u0026#34;b\u0026#34;, y + 5, x + 5, img_pad, threshold, r_gain, gr_gain, gb_gain, b_gain); break; case BAYER_PATTERN_BGGR: b = img_pad-\u0026gt;at(y + 4, x + 4); gb = img_pad-\u0026gt;at(y + 4, x + 5); gr = img_pad-\u0026gt;at(y + 5, x + 4); r = img_pad-\u0026gt;at(y + 5, x + 5); img.at(y, x) = __cnf(\u0026#34;b\u0026#34;, y + 4, x + 4, img_pad, threshold, r_gain, gr_gain, gb_gain, b_gain); img.at(y, x + 1) = gb; img.at(y + 1, x) = gr; img.at(y + 1, x + 1) = __cnf(\u0026#34;r\u0026#34;, y + 5, x + 5, img_pad, threshold, r_gain, gr_gain, gb_gain, b_gain); break; case BAYER_PATTERN_GBRG: gb = img_pad-\u0026gt;at(y + 4, x + 4); b = img_pad-\u0026gt;at(y + 4, x + 5); r = img_pad-\u0026gt;at(y + 5, x + 4); gr = img_pad-\u0026gt;at(y + 5, x + 5); img.at(y, x) = gb; img.at(y, x + 1) = __cnf(\u0026#34;b\u0026#34;, y + 4, x + 5, img_pad, threshold, r_gain, gr_gain, gb_gain, b_gain); img.at(y + 1, x) = __cnf(\u0026#34;r\u0026#34;, y + 5, x + 4, img_pad, threshold, r_gain, gr_gain, gb_gain, b_gain); img.at(y + 1, x + 1) = gr; break; case BAYER_PATTERN_GRBG: gr = img_pad-\u0026gt;at(y + 4, x + 4); r = img_pad-\u0026gt;at(y + 4, x + 5); b = img_pad-\u0026gt;at(y + 5, x + 4); gb = img_pad-\u0026gt;at(y + 5, x + 5); img.at(y, x) = gr; img.at(y, x + 1) = __cnf(\u0026#34;r\u0026#34;, y + 4, x + 5, img_pad, threshold, r_gain, gr_gain, gb_gain, b_gain); img.at(y + 1, x) = __cnf(\u0026#34;b\u0026#34;, y + 5, x + 4, img_pad, threshold, r_gain, gr_gain, gb_gain, b_gain); img.at(y + 1, x + 1) = gb; break; case BAYER_PATTERN_UNKNOWN: default: TRACE_DEBUG_LOG_ERROR(\u0026#34;Unknown Bayer Pattern:%s\\n\u0026#34;, bayer_pattern); break; } } } img.clip(0, clip); delete img_pad; } æŠ—é”¯é½¿æ»¤æ³¢ï¼ˆAnti-aliasing Filteringï¼ŒAAFï¼‰ å¦‚æœæ‹æ‘„çš„å›¾åƒä¸­å«æœ‰å¤§é‡é«˜é¢‘æˆåˆ†ï¼Œåœ¨é™é‡‡æ ·æ—¶å°±ä¼šäº§ç”Ÿé”¯é½¿ï¼ˆaliasingï¼‰ï¼Œè¦å»é™¤é”¯é½¿ï¼Œéœ€è¦å¯¹åŸå›¾åƒè¿›è¡Œå¹³æ»‘ã€‚å¸¸ç”¨çš„æ–¹æ³•æœ‰é«˜æ–¯æ»¤æ³¢å™¨ï¼ˆGaussian Filterï¼‰å’ŒåŒè¾¹æ»¤æ³¢å™¨ï¼ˆBilateral Filterï¼‰ã€‚\né«˜æ–¯æ»¤æ³¢å™¨ $$G(x,y)=\\frac1{2\\pi\\sigma^2}\\exp\\left(-\\frac{x^2+y^2}{2\\sigma^2}\\right)$$\nå…¶ä¸­:\n$\\bullet\\quad G(x,y)$æ˜¯é«˜æ–¯æ ¸åœ¨åæ ‡(x,y)çš„å€¼;\n$\\bullet\\quad \\sigma$æ˜¯é«˜æ–¯åˆ†å¸ƒçš„æ ‡å‡†å·®,å†³å®šæ»¤æ³¢å™¨çš„å¹³æ»‘å¼ºåº¦;\n$\\bullet\\quad x,y$æ˜¯è·ç¦»æ ¸ä¸­å¿ƒçš„åæ ‡ã€‚ åŒè¾¹æ»¤æ³¢å™¨ $$W(p,q)=\\exp\\left(-\\frac{\\|p-q\\|^2}{2\\sigma_s^2}\\right)\\cdot\\exp\\left(-\\frac{|I(p)-I(q)|^2}{2\\sigma_r^2}\\right)$$\nå…¶ä¸­:\n$\\bullet\\quad W(p,q)$æ˜¯åƒç´ qå¯¹pçš„æƒé‡;\n$\\bullet\\quad|p-q|$æ˜¯ä¸¤åƒç´ åœ¨ç©ºé—´ä¸Šçš„è·ç¦»;\n$\\bullet\\quad|I(p)-I(q)|$æ˜¯ä¸¤åƒç´ ç°åº¦å€¼çš„å·®å¼‚;\n$\\bullet\\quad\\sigma_s$æ˜¯ç©ºé—´åŸŸé«˜æ–¯æ ‡å‡†å·®;\n$\\bullet\\quad\\sigma_r$æ˜¯å¼ºåº¦åŸŸé«˜æ–¯æ ‡å‡†å·®ã€‚\næ»¤æ³¢ç»“æœ:\n$$I^{\\prime} (p)=\\frac{\\sum_{q\\in S}W(p,q)\\cdot I(q)}{\\sum_{q\\in S}W(p,q)}$$\nå…¶ä¸­:Sæ˜¯æ»¤æ³¢çª—å£,$I^{\\prime}(p)$æ˜¯åƒç´ pçš„æ»¤æ³¢å€¼ã€‚ ä¸¤è€…å¯¹æ¯”ï¼š\nç‰¹æ€§ é«˜æ–¯æ»¤æ³¢å™¨ åŒè¾¹æ»¤æ³¢å™¨ æ€§è´¨ çº¿æ€§æ»¤æ³¢ éçº¿æ€§æ»¤æ³¢ è¾¹ç¼˜ä¿ç•™ ä¸ä¿ç•™è¾¹ç¼˜ï¼Œæ¨¡ç³Šè¾¹ç¼˜ ä¿ç•™è¾¹ç¼˜ï¼Œå¯¹è¾¹ç¼˜å½±å“è¾ƒå° è®¡ç®—å¤æ‚åº¦ ä½ é«˜ å®ç°éš¾åº¦ ç®€å• è¾ƒå¤æ‚ é€‚ç”¨åœºæ™¯ å¿«é€Ÿå¹³æ»‘ã€é«˜é¢‘å™ªå£°è¾ƒå°‘çš„åœºæ™¯ é«˜è´¨é‡æŠ—é”¯é½¿ï¼Œä¿ç•™çº¹ç†å’Œè¾¹ç¼˜ ç¤ºä¾‹ä»£ç ï¼ˆåŒè¾¹æ»¤æ³¢å™¨ âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 /** * @brief Computes the Gaussian weight for a given difference. * * @param x The difference (distance in space or intensity). * @param sigma The standard deviation of the Gaussian function. * @return The computed Gaussian weight. */ double gaussian(double x, double sigma) { return std::exp(-x * x / (2.0 * sigma * sigma)); } /** * @brief Applies a bilateral filter to an ImageRaw object. * * @param src Input image. * @param dst Output image (should be pre-initialized to the same size as src). * @param d The diameter of the filter kernel (must be an odd number). * @param sigmaColor The standard deviation in the intensity space. * @param sigmaSpace The standard deviation in the spatial space. */ void applyBilateralFilter(const ImageRaw\u0026amp; src, ImageRaw\u0026amp; dst, int d, double sigmaColor, double sigmaSpace) { int height = src.getHeight(); int width = src.getWidth(); // Ensure kernel size is odd if (d % 2 == 0) { throw std::invalid_argument(\u0026#34;Kernel size must be odd.\u0026#34;); } // Precompute spatial Gaussian weights int radius = d / 2; std::vector\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt; spatialKernel(d, std::vector\u0026lt;double\u0026gt;(d, 0.0)); for (int i = -radius; i \u0026lt;= radius; ++i) { for (int j = -radius; j \u0026lt;= radius; ++j) { spatialKernel[i + radius][j + radius] = gaussian(std::sqrt(i * i + j * j), sigmaSpace); } } // Perform bilateral filtering for (int i = 0; i \u0026lt; height; ++i) { for (int j = 0; j \u0026lt; width; ++j) { double weightedSum = 0.0; double normalizationFactor = 0.0; uint16_t centerPixel = src.at(i, j); for (int ki = -radius; ki \u0026lt;= radius; ++ki) { for (int kj = -radius; kj \u0026lt;= radius; ++kj) { int ni = i + ki; int nj = j + kj; // Skip out-of-bound pixels if (ni \u0026lt; 0 || ni \u0026gt;= height || nj \u0026lt; 0 || nj \u0026gt;= width) { continue; } uint16_t neighborPixel = src.at(ni, nj); // Compute intensity Gaussian weight double intensityWeight = gaussian(std::abs((int)centerPixel - (int)neighborPixel), sigmaColor); // Compute final weight double weight = spatialKernel[ki + radius][kj + radius] * intensityWeight; // Accumulate weighted sum and normalization factor weightedSum += neighborPixel * weight; normalizationFactor += weight; } } // Assign the filtered value to the destination image dst.at(i, j) = static_cast\u0026lt;uint16_t\u0026gt;(weightedSum / normalizationFactor); } } } è‡ªåŠ¨ç™½å¹³è¡¡ï¼ˆAuto White Balanceï¼ŒAWBï¼‰ äººçš„è§†è§‰å’Œç¥ç»ç³»ç»Ÿå…·æœ‰è‰²å½©æ’å¸¸æ€§ï¼Œåœ¨çœ‹åˆ°ç™½è‰²ç‰©ä½“çš„æ—¶å€™åŸºæœ¬ä¸å—ç¯å¢ƒå…‰æºå˜åŒ–çš„å½±å“ã€‚ä½†æ˜¯image sensorå¹¶ä¸èƒ½åƒäººçš„è§†è§‰ç³»ç»Ÿä¸€æ ·è‡ªåŠ¨è°ƒèŠ‚ï¼Œåœ¨ä¸åŒè‰²æ¸©å…‰æºä¸‹ï¼Œæ‹å‡ºçš„ç…§ç‰‡ä¸­ç™½è‰²ä¼šå‡ºç°åè‰²çš„æƒ…å†µã€‚è‡ªåŠ¨ç™½å¹³è¡¡å°±æ˜¯ç”¨æ¥æ¨¡æ‹Ÿäººç±»çš„è‰²å½©æ’å¸¸èƒ½åŠ›ï¼Œåœ¨å›¾åƒä¸­å»é™¤å…‰æºå¼•èµ·çš„åè‰²ï¼Œä»è€Œè¿˜åŸè‡ªç„¶çš„è‰²å½©ã€‚\nè‡ªåŠ¨ç™½å¹³è¡¡ç®—æ³•æ ¹æ®æŠ€æœ¯è·¯çº¿å¯ä»¥å½’ç»“ä¸ºå‡ å¤§ç±»ï¼Œåˆ†åˆ«æ˜¯ï¼š\nåœºæ™¯å‡è®¾æ¨¡å‹ï¼šç°åº¦ä¸–ç•Œã€å®Œç¾åå°„ ç‚¹ç»Ÿè®¡æ¨¡å‹ï¼šç™½è‰²ç‚¹ä¼°è®¡ã€åˆ†å—æƒé‡ ç°åº¦ä¸–ç•Œç®—æ³•\nè¯¥ç®—æ³•å‡è®¾ï¼šå¯¹äºä¸€å‰¯æœ‰ç€ä¸°å¯Œè‰²å½©çš„å›¾ç‰‡ï¼Œå›¾åƒä¸ŠRã€Gã€Bä¸‰ä¸ªé€šé“çš„å¹³å‡å€¼åº”è¯¥ç­‰äºä¸€ä¸ªè¢«ç§°ä¸ºâ€œç°è‰²â€çš„å€¼$K$ã€‚è‡³äºâ€œç°è‰²â€å€¼Kçš„é€‰æ‹©ï¼Œä¸€ç§æ–¹æ³•æ˜¯å°†å¾…å¤„ç†å›¾ç‰‡ä¸‰ä¸ªé€šé“å‡å€¼çš„å‡å€¼ä½œä¸ºâ€œç°è‰²â€å€¼$K$ã€‚å½“ç¡®å®šäº†ç°è‰²å€¼Kä¹‹åï¼Œå¾…å¤„ç†å›¾ç‰‡å„ä¸ªé€šé“çš„æ ¡æ­£ç³»æ•°åˆ†åˆ«ä¸ºï¼š$k_r=K/R_{mean}ï¼Œk_g=K/G_{mean}ï¼Œk_b=K/B_{mean}$ï¼Œå…¶ä¸­$R_{mean}ï¼ŒG_{mean}å’ŒB_{mean}$åˆ†åˆ«ä¸ºå›¾åƒRã€Gã€Bé€šé“çš„å‡å€¼ã€‚ ç¤ºä¾‹ä»£ç  âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;stdexcept\u0026gt; /** * @brief Apply the Gray World Algorithm to an ImageRaw. * * This algorithm adjusts the R, G, and B channels of the input image so that their * mean values are equal to a common gray level \\( K \\). This corrects the overall * color balance of the image. * * @param src Input image. Must have 3 channels (RGB format). * @param dst Output image. Must have the same size as the input image. */ void grayWorldAlgorithm(const ImageRaw\u0026amp; src, ImageRaw\u0026amp; dst) { // Validate input image dimensions if (src.getWidth() != dst.getWidth() || src.getHeight() != dst.getHeight()) { throw std::invalid_argument(\u0026#34;Input and output images must have the same dimensions.\u0026#34;); } int width = src.getWidth(); int height = src.getHeight(); // Accumulators for R, G, B channel sums uint64_t sumR = 0, sumG = 0, sumB = 0; int numPixels = width * height; // Compute channel-wise sums for (int i = 0; i \u0026lt; height; ++i) { for (int j = 0; j \u0026lt; width; ++j) { uint16_t r = src.at(i, j * 3); // Assume RGB channels are stored in sequence uint16_t g = src.at(i, j * 3 + 1); uint16_t b = src.at(i, j * 3 + 2); sumR += r; sumG += g; sumB += b; } } // Compute mean values for each channel double meanR = static_cast\u0026lt;double\u0026gt;(sumR) / numPixels; double meanG = static_cast\u0026lt;double\u0026gt;(sumG) / numPixels; double meanB = static_cast\u0026lt;double\u0026gt;(sumB) / numPixels; // Compute the target gray value \\( K \\) as the average of all channel means double K = (meanR + meanG + meanB) / 3.0; // Compute correction factors double kR = K / meanR; double kG = K / meanG; double kB = K / meanB; // Apply correction to each pixel for (int i = 0; i \u0026lt; height; ++i) { for (int j = 0; j \u0026lt; width; ++j) { uint16_t r = src.at(i, j * 3); uint16_t g = src.at(i, j * 3 + 1); uint16_t b = src.at(i, j * 3 + 2); // Adjust each channel and clip the values to the valid range dst.at(i, j * 3) = static_cast\u0026lt;uint16_t\u0026gt;(std::min(std::max(r * kR, 0.0), 65535.0)); dst.at(i, j * 3 + 1) = static_cast\u0026lt;uint16_t\u0026gt;(std::min(std::max(g * kG, 0.0), 65535.0)); dst.at(i, j * 3 + 2) = static_cast\u0026lt;uint16_t\u0026gt;(std::min(std::max(b * kB, 0.0), 65535.0)); } } } å®Œç¾åå°„æ³• è¯¥ç®—æ³•å‡è®¾ï¼šâ€œé•œé¢â€å¯ä»¥å®Œå…¨å‘å°„å…‰æºç…§å°„åœ¨ç‰©ä½“ä¸Šé¢çš„å…‰çº¿ã€‚å› æ­¤ï¼Œå¦‚æœå›¾åƒä¸­å­˜åœ¨ä¸€ä¸ªâ€œé•œé¢â€çš„è¯ï¼Œé‚£ä¹ˆåœ¨ç‰¹å®šå…‰æºä¸‹ï¼Œå¯ä»¥å°†æ‰€è·å¾—çš„â€œé•œé¢â€çš„è‰²å½©ä¿¡æ¯è®¤ä¸ºæ˜¯å½“å‰å…‰æºçš„ä¿¡æ¯ã€‚åœ¨è¿›è¡Œç™½å¹³è¡¡æ ¡å‡†çš„æ—¶å€™ï¼Œå‡è®¾å›¾ç‰‡ä¸Šå­˜åœ¨ä¸€ä¸ªå¯ä»¥å®Œå…¨åå°„å…‰æºçš„â€œé•œé¢â€ï¼Œé‚£ä¹ˆåœ¨ç»å…¸å…‰æºä¸‹å›¾ç‰‡ä¸­å°±åº”è¯¥å­˜åœ¨ä¸€ä¸ªä¸‰åˆºæ¿€å€¼ä¸º[255,255,255]çº¯ç™½è‰²åƒç´ ç‚¹ï¼ˆæœ‰å¤šç§ç™½è‰²ç‚¹å®šä¹‰ï¼Œè¿™æ˜¯ä¸€ç§ï¼‰ï¼Œæ­¤æ—¶å¾…å¤„ç†å›¾ç‰‡å„ä¸ªé€šé“çš„æ ¡æ­£ç³»æ•°åˆ†åˆ«ä¸ºï¼š$k_r=255/R_{max}ï¼Œk_g=255/G_{max}ï¼Œk_b=255/B_{max}$ï¼Œå…¶ä¸­$R_{max}ï¼ŒG_{max}å’ŒB_{max}$åˆ†åˆ«ä¸ºå›¾åƒRã€Gã€Bé€šé“çš„æœ€å¤§å€¼ã€‚ ç¤ºä¾‹ä»£ç -å®Œç¾åå°„æ³• âœ– ç»Ÿè®¡åŠ æƒç™½ç‚¹æ³•ï¼ˆé€šå¸¸åœ¨éœ€è¦æ¯”è¾ƒé«˜å›¾åƒè´¨é‡æ—¶ä½¿ç”¨ï¼‰ è¯¥ç®—æ³•é¦–å…ˆéœ€è¦å¯¹ä¼ æ„Ÿå™¨è¿›è¡Œå…‰æºæ ‡å®šå¾—åˆ°è‰²æ¸©æ›²çº¿ã€‚æŠ˜çº¿ä¸Šçš„ç‚¹æ˜¯åœ¨äº§çº¿ä¸Šé’ˆå¯¹ä¸åŒå…‰æº(D65, Aå…‰ï¼ŒHå…‰ç­‰)ä½¿ç”¨æ ‡å‡†ç™½/ç°å¡çº¸æ‹å‡ºç…§ç‰‡ç®—å‡ºæ¥çš„$R_{gain}=R_{mean}/G_{mean}$å’Œ$B_{gain}=B_{mean}/G_{mean}$åæ ‡ã€‚æ ¡å‡†æ—¶å°†å›¾ç‰‡åˆ†ä¸ºMå—ï¼Œåˆ†åˆ«è®¡ç®—æ¯å—çš„$R_{gain}$å’Œ$B_{gain}$å’Œï¼Œä½œä¸ºä¸€ä¸ªâ€œç™½ç‚¹â€ï¼Œå°†å€¼é è¿‘æŠ˜çº¿åŒºåŸŸ(çº¢è‰²)çš„â€œç™½ç‚¹â€æƒé‡åŠ é«˜ï¼Œè¿œç¦»çš„(è“è‰²)æƒé‡é™ä½ï¼Œå†è®¡ç®—å‡ºåŠ æƒå¹³å‡å€¼å¾—åˆ°æœ€ç»ˆâ€œç™½ç‚¹â€çš„$R_{gain}$å’Œ$B_{gain}$ï¼Œä½¿ç”¨æŠ˜çº¿ä¸Šçš„ä¸åŒç‚¹åšæ’å€¼è®¡ç®—å‡ºä¸€ä¸ªæœ€ç»ˆ$R_{gain}$å’Œ$B_{gain}$å€¼ã€‚ ç¤ºä¾‹ä»£ç -ç»Ÿè®¡åŠ æƒç™½ç‚¹æ³• âœ– å»é©¬èµ›å…‹ï¼ˆDemosaicingï¼‰ ä¹‹å‰æåˆ°äº†æ™®é€šçš„CMOSå›¾åƒä¼ æ„Ÿå™¨æ— æ³•â€œæ•è·â€è‰²å½©ä¿¡æ¯ï¼Œè§£å†³æ–¹æ³•æ˜¯é€šè¿‡Bayeré˜µåˆ—çš„å¸¦æœ‰ä¸åŒé¢œè‰²æ»¤å…‰ç‰‡çš„åƒç´ ç‚¹è®°å½•å¯¹åº”é€šé“çš„äº®åº¦å€¼ï¼Œæœ€åæ’å€¼å¾—åˆ°æ¯ä¸ªåƒç´ ç‚¹çš„RGBä¸‰é€šé“å€¼ã€‚ç”±äºé€šè¿‡CMOSå¾—åˆ°çš„Bayeræ ¼å¼çš„RAWå›¾æ”¾å¤§çœ‹èµ·æ¥å°±åƒé©¬èµ›å…‹ï¼Œè¿™ä¸ªä»ç°åº¦å›¾ç‰‡è¿˜åŸå›¾ç‰‡è‰²å½©çš„è¿‡ç¨‹åˆå«å»é©¬èµ›å…‹ã€‚ï¼ˆDemosaicingï¼‰\nDemosiacçš„æ’å€¼ä¸€èˆ¬éµå¾ªä»¥ä¸‹å‡ ä¸ªåŸåˆ™ï¼š\n1.å…ˆå¯¹Gåˆ†é‡è¿›è¡Œæ’å€¼ï¼Œå› ä¸ºGé€šé“çš„åƒç´ æ•°é‡æ˜¯GBé€šé“çš„ä¸¤å€\n2.æ’å€¼æ—¶é‡‡ç”¨æ–¹å‘æ€§æ’å€¼ï¼Œå³å¦‚æœæ˜¯å‚ç›´çš„è¾¹ç¼˜ï¼Œåˆ™é‡‡ç”¨ä¸Šä¸‹çš„åƒç´ æ’å€¼ï¼Œè€Œä¸é€‰ç”¨å·¦å³\n3.å“ˆå¯†å°”é¡¿(Hamilton)è‰²å·®æ’å®šåŸç†ï¼Œ$R(i,j)-G(i,j)=R(i,j+1)-G(i,j+1)$ï¼Œå³ç›¸é‚»ç‚¹è‰²å·®ç›¸åŒ\n4.å„ä¸ªé¢œè‰²åˆ†é‡åœ¨åŒä¸€åƒç´ ç‚¹å¤„çš„é«˜é¢‘åˆ†é‡å¯è®¤ä¸ºæ˜¯ç›¸åŒçš„\nå…·ä½“è€Œè¨€ï¼Œä¸€ä¸ªç®€å•çš„å»é©¬èµ›å…‹æµç¨‹å¯ä»¥æ˜¯ï¼š\n1.è·å–å›¾åƒä¸­çš„ç‰©ä½“çš„è¾¹ç¼˜ 2.æ ¹æ®è¾¹ç¼˜ä¿¡æ¯æ’å€¼é‡å»ºGåˆ†é‡ 3.æ ¹æ®å“ˆå¯†å°”é¡¿æå‡ºçš„è‰²å·®æ’å®šç†è®ºï¼Œæ ¹æ®è‰²å·®æ’å€¼é‡å»ºRå’ŒBåˆ†é‡ 4.ä¸€äº›åå¤„ç†ï¼ŒåŒ…æ‹¬ä¼ªå½©è‰²æŠ‘åˆ¶ï¼ˆpseudocolor suppressionï¼‰å’Œæ‹‰é“¾æ•ˆåº”æŠ‘åˆ¶ï¼ˆzipper cancellingï¼‰ç­‰\næ‰©å±•é˜…è¯»ï¼šä½æˆæœ¬è¾¹ç¼˜ä¸è‰²å·®æ’å€¼å»é©¬èµ›å…‹ç®—æ³•ï¼ˆLEDï¼‰\nç¤ºä¾‹ä»£ç -LEDæ³• âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // ç¤ºä¾‹ä»£ç ï¼šå»é©¬èµ›å…‹ç®—æ³•å®ç°ï¼ˆåŸºäºæ–¹å‘æ€§æ’å€¼å’Œè‰²å·®æ’å®šç†è®ºï¼‰ #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; // è·å–æ¢¯åº¦ä¿¡æ¯ void compute_gradients(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; image, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grad_h, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grad_v) { int rows = image.size(); int cols = image[0].size(); grad_h.resize(rows, vector\u0026lt;int\u0026gt;(cols, 0)); grad_v.resize(rows, vector\u0026lt;int\u0026gt;(cols, 0)); for (int i = 1; i \u0026lt; rows - 1; ++i) { for (int j = 1; j \u0026lt; cols - 1; ++j) { grad_h[i][j] = abs(image[i][j + 1] - image[i][j - 1]); grad_v[i][j] = abs(image[i + 1][j] - image[i - 1][j]); } } } // æ–¹å‘æ€§æ’å€¼é‡å»ºGåˆ†é‡ void reconstruct_green(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; bayer, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; green, const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grad_h, const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grad_v) { int rows = bayer.size(); int cols = bayer[0].size(); green = bayer; // åˆå§‹ä¸º Bayer å›¾åƒ for (int i = 1; i \u0026lt; rows - 1; ++i) { for (int j = 1; j \u0026lt; cols - 1; ++j) { if ((i + j) % 2 == 0) { // å½“å‰åƒç´ ä¸æ˜¯ G if (grad_h[i][j] \u0026lt; grad_v[i][j]) { green[i][j] = (bayer[i][j - 1] + bayer[i][j + 1]) / 2; } else { green[i][j] = (bayer[i - 1][j] + bayer[i + 1][j]) / 2; } } } } } // æ ¹æ®è‰²å·®æ’å®šç†è®ºé‡å»º R å’Œ B åˆ†é‡ void reconstruct_red_blue(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; bayer, const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; green, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; red, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; blue) { int rows = bayer.size(); int cols = bayer[0].size(); red = bayer; // åˆå§‹ä¸º Bayer å›¾åƒ blue = bayer; for (int i = 1; i \u0026lt; rows - 1; ++i) { for (int j = 1; j \u0026lt; cols - 1; ++j) { if ((i % 2 == 0 \u0026amp;\u0026amp; j % 2 == 1) || (i % 2 == 1 \u0026amp;\u0026amp; j % 2 == 0)) { // å½“å‰åƒç´ æ˜¯ G red[i][j] = green[i][j] + (bayer[i][j + 1] - green[i][j + 1] + bayer[i][j - 1] - green[i][j - 1]) / 2; blue[i][j] = green[i][j] + (bayer[i + 1][j] - green[i + 1][j] + bayer[i - 1][j] - green[i - 1][j]) / 2; } else if ((i % 2 == 0 \u0026amp;\u0026amp; j % 2 == 0)) { // å½“å‰åƒç´ æ˜¯ B red[i][j] = green[i][j] + (bayer[i + 1][j + 1] - green[i + 1][j + 1] + bayer[i - 1][j - 1] - green[i - 1][j - 1]) / 2; } else { // å½“å‰åƒç´ æ˜¯ R blue[i][j] = green[i][j] + (bayer[i + 1][j + 1] - green[i + 1][j + 1] + bayer[i - 1][j - 1] - green[i - 1][j - 1]) / 2; } } } } // ä¼ªå½©è‰²æŠ‘åˆ¶ä¸æ‹‰é“¾æ•ˆåº”å»é™¤çš„åå¤„ç† void post_process(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; red, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; green, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; blue) { int rows = red.size(); int cols = red[0].size(); for (int i = 1; i \u0026lt; rows - 1; ++i) { for (int j = 1; j \u0026lt; cols - 1; ++j) { red[i][j] = min(max(red[i][j], 0), 255); green[i][j] = min(max(green[i][j], 0), 255); blue[i][j] = min(max(blue[i][j], 0), 255); } } } // ä¸»å‡½æ•°ï¼šå»é©¬èµ›å…‹ void demosaic(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; bayer, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; red, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; green, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; blue) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; grad_h, grad_v; compute_gradients(bayer, grad_h, grad_v); // è®¡ç®—æ¢¯åº¦ reconstruct_green(bayer, green, grad_h, grad_v); // é‡å»º G åˆ†é‡ reconstruct_red_blue(bayer, green, red, blue); // é‡å»º R å’Œ B åˆ†é‡ post_process(red, green, blue); // åå¤„ç† } è‰²å½©æ ¡æ­£ï¼ˆColor Correctionï¼‰ $$\\begin{bmatrix}R'\\\\G'\\\\B'\\end{bmatrix}=\\begin{bmatrix}m_{11}\u0026m_{12}\u0026m_{13}\\\\m_{21}\u0026m_{22}\u0026m_{23}\\\\m_{31}\u0026m_{32}\u0026m_{33}\\end{bmatrix}\\begin{bmatrix}R\\\\G\\\\B\\end{bmatrix}$$ å…¶ä¸­R\u0026rsquo;G\u0026rsquo;B\u0026rsquo;æ˜¯æ ¡æ­£åçš„é¢œè‰²å€¼ï¼ŒRGBæ˜¯ä¼ æ„Ÿå™¨æ•è·çš„åŸå§‹é¢œè‰²å€¼ã€‚\nç¤ºä¾‹ä»£ç  âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; // è‰²å½©æ ¡æ­£çŸ©é˜µå®šä¹‰ const std::array\u0026lt;std::array\u0026lt;float, 3\u0026gt;, 3\u0026gt; CCM = {{ {1.2f, -0.1f, -0.1f}, {-0.2f, 1.3f, -0.1f}, {-0.1f, -0.2f, 1.4f} }}; // å¯¹å•ä¸ªåƒç´ ç‚¹è¿›è¡Œè‰²å½©æ ¡æ­£ std::array\u0026lt;float, 3\u0026gt; colorCorrection(const std::array\u0026lt;float, 3\u0026gt;\u0026amp; input) { std::array\u0026lt;float, 3\u0026gt; output = {0.0f, 0.0f, 0.0f}; for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 0; j \u0026lt; 3; ++j) { output[i] += CCM[i][j] * input[j]; } } return output; } è‰²å½©æ ¡æ­£åï¼Œä¹Ÿå¯ä»¥æ ¹æ®éœ€æ±‚å¯¹æ ¡æ­£åçš„é¢œè‰²è¿›ä¸€æ­¥è°ƒèŠ‚,ä¾‹å¦‚è‰²å½©å¢å¼ºæˆ–é£æ ¼åŒ–\nä¼½é©¬çŸ«æ­£ï¼ˆGamma Correctionï¼‰ äººç±»å¯¹äº®åº¦çš„æ„ŸçŸ¥å¹¶éçº¿æ€§ï¼Œè€Œæ˜¯æ¥è¿‘å¹‚å‡½æ•°$L\\propto I^{0.43}$ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯¹æš—éƒ¨ç»†èŠ‚æ›´åŠ æ•æ„Ÿï¼Œå¯¹äº®éƒ¨å˜åŒ–çš„æ„ŸçŸ¥èƒ½åŠ›è¾ƒå¼±ã€‚ä¸ºäº†é«˜æ•ˆåˆ©ç”¨æœ‰é™çš„ä½æ·±ï¼ˆbitæ•°ï¼‰ï¼Œä¼˜åŒ–ç¼–ç æ•ˆç‡ï¼Œå›¾åƒç¼–ç ä¼šæŒ‰ç…§äººç±»çš„è§†è§‰ç‰¹æ€§è¿›è¡Œéçº¿æ€§å˜æ¢ï¼Œå°†æ›´å¤šçš„ç¼–ç ç²¾åº¦åˆ†é…åˆ°æš—éƒ¨ï¼ˆäººç±»æ›´æ•æ„Ÿçš„éƒ¨åˆ†ï¼‰ï¼Œå‡å°‘äº®éƒ¨ï¼ˆäººç±»è¾ƒä¸æ•æ„Ÿéƒ¨åˆ†ï¼‰çš„ç²¾åº¦ã€‚è¿™ç§éçº¿æ€§ç¼–ç é€šå¸¸è¢«ç§°ä¸ºgammaç¼–ç ã€‚åŸºäºè¿™ç§ç¼–ç ç‰¹æ€§ï¼Œæ˜¾ç¤ºè®¾å¤‡ï¼ˆå¦‚æ˜¾ç¤ºå™¨ï¼‰ä¸ºäº†ä½¿å›¾åƒåœ¨è§†è§‰ä¸Šçœ‹èµ·æ¥æ­£ç¡®ï¼Œä¼šæ‰§è¡Œâ€œåGammaâ€æ“ä½œ$I_{output}=I_{input}^{\\frac1\\gamma}ï¼Œ\\gamma$å¸¸å–2.2ï¼Œå³å°†ç¼–ç å›¾åƒçš„éçº¿æ€§äº®åº¦è¿˜åŸä¸ºçº¿æ€§äº®åº¦ã€‚\nä¸ºä»€ä¹ˆéœ€è¦Gammaç¼–ç ï¼š\nå¦‚æœç›´æ¥å¯¹å›¾åƒè¿›è¡Œçº¿æ€§ç¼–ç å¹¶å­˜å‚¨æˆ–ä¼ è¾“ï¼Œæš—éƒ¨ç»†èŠ‚ä¼šè¢«è¿‡åº¦å‹ç¼©ï¼Œé€ æˆé‡è¦çš„è§†è§‰ä¿¡æ¯ä¸¢å¤±ã€‚åŒæ—¶ï¼Œæ˜¾ç¤ºè®¾å¤‡çš„åGammaæ ¡æ­£ä¼šè¿›ä¸€æ­¥æ”¾å¤§è¿™ç§ç°è±¡ï¼Œä½¿å¾—å›¾åƒæš—éƒ¨æ˜¾ç¤ºæ›´å·®ã€‚å› æ­¤ï¼Œä¸ºäº†ä¿è¯åœ¨æ˜¾ç¤ºè®¾å¤‡ä¸Šä¿æŒé¢„æœŸçš„äº®åº¦å’Œå¯¹æ¯”åº¦ï¼Œæ‹æ‘„çš„å›¾åƒéœ€è¦åœ¨ç¼–ç é˜¶æ®µè¿›è¡ŒGammaç¼–ç ã€‚\nç¤ºä¾‹ä»£ç  âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;cmath\u0026gt; // ä¼½é©¬çŸ«æ­£å‡½æ•° float gammaCorrection(float value, float gamma) { return std::pow(value, gamma); } // å¯¹æ•´å¹…å›¾åƒè¿›è¡Œä¼½é©¬çŸ«æ­£ void processImageGammaCorrection(std::vector\u0026lt;std::array\u0026lt;float, 3\u0026gt;\u0026gt;\u0026amp; image, float gamma) { for (auto\u0026amp; pixel : image) { for (int i = 0; i \u0026lt; 3; ++i) { pixel[i] = gammaCorrection(pixel[i], gamma); } } } å…¶ä»–å›¾åƒå¤„ç†ç®—æ³• ç›´æ–¹å›¾å‡è¡¡åŒ–ï¼ˆHistogram Equalizationï¼‰ ç›´æ–¹å›¾å‡è¡¡åŒ–æ˜¯ä¸€ç§å›¾åƒå¤„ç†æŠ€æœ¯ï¼Œé€šè¿‡è°ƒæ•´å›¾åƒçš„ç°åº¦çº§åˆ†å¸ƒï¼Œä½¿å¾—å›¾åƒçš„å¯¹æ¯”åº¦å¾—åˆ°æ”¹å–„ï¼Œä½†å¦‚æœå¯¹é«˜å¯¹æ¯”åº¦å›¾åƒä½¿ç”¨æ—¶å¯èƒ½å¯¼è‡´ç»†èŠ‚ä¸¢å¤±æˆ–å™ªå£°å¢å¼ºã€‚ç›´æ–¹å›¾å‡è¡¡åŒ–æ›´é€‚ç”¨äºæ›å…‰ä¸è¶³ã€å¯¹æ¯”åº¦ä½çš„å›¾åƒï¼Œå¦‚åŒ»å­¦å½±åƒã€å«æ˜Ÿå›¾åƒæˆ–è®¡ç®—æœºè§†è§‰ä¸­çš„å›¾åƒé¢„å¤„ç†ã€‚\nç¤ºä¾‹ä»£ç  âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; // è®¡ç®—ç´¯ç§¯åˆ†å¸ƒå‡½æ•°ï¼ˆCDFï¼‰ std::vector\u0026lt;float\u0026gt; calculateCDF(const std::vector\u0026lt;int\u0026gt;\u0026amp; histogram) { std::vector\u0026lt;float\u0026gt; cdf(histogram.size(), 0.0f); std::partial_sum(histogram.begin(), histogram.end(), cdf.begin()); float maxValue = cdf.back(); for (float\u0026amp; val : cdf) { val /= maxValue; } return cdf; } // åº”ç”¨ç›´æ–¹å›¾å‡è¡¡åŒ– void histogramEqualization(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; image, int maxValue) { std::vector\u0026lt;int\u0026gt; histogram(maxValue + 1, 0); // ç»Ÿè®¡ç›´æ–¹å›¾ for (const auto\u0026amp; row : image) { for (int value : row) { ++histogram[value]; } } // è®¡ç®—CDF std::vector\u0026lt;float\u0026gt; cdf = calculateCDF(histogram); // åº”ç”¨å‡è¡¡åŒ– for (auto\u0026amp; row : image) { for (int\u0026amp; value : row) { value = static_cast\u0026lt;int\u0026gt;(cdf[value] * maxValue); } } } é¢œè‰²ç©ºé—´è½¬æ¢ï¼ˆColor Space Conversionï¼‰ â–  RGB(Red, Green, Blue)æ˜¯ä¸€ç§åŸºäºåŠ è‰²æ¨¡å‹çš„é¢œè‰²ç©ºé—´ï¼Œè¡¨ç¤ºçº¢è‰²ã€ç»¿è‰²å’Œè“è‰²ä¸‰ä¸ªé¢œè‰²é€šé“çš„å¼ºåº¦ã€‚RGBæ¨¡å‹å¹¿æ³›ç”¨äºæ˜¾ç¤ºè®¾å¤‡ï¼ˆå¦‚è®¡ç®—æœºæ˜¾ç¤ºå™¨ã€ç”µè§†ç­‰ï¼‰ï¼Œå®ƒé€šè¿‡ä¸åŒå¼ºåº¦çš„çº¢ã€ç»¿ã€è“å…‰çš„ç»„åˆæ¥ç”Ÿæˆå„ç§é¢œè‰²ã€‚é¢œè‰²çš„æ··åˆæ–¹å¼æ˜¯åŠ æ³•çš„ï¼Œå³æ‰€æœ‰é€šé“çš„å…‰å¼ºåº¦åŠ èµ·æ¥ä¼šä½¿é¢œè‰²å˜å¾—æ›´äº®ã€‚\nâ–  CMYK(Cyan, Magenta, Yellow, Black)è¡¨ç¤ºå°åˆ·ä¸Šç”¨çš„å››ç§é¢œè‰²ï¼Œæ˜¯RGBçš„è¡¥è‰²ã€‚ç”±äºåœ¨å®é™…åº”ç”¨ä¸­ï¼Œé’è‰²ã€æ´‹çº¢è‰²å’Œé»„è‰²å¾ˆéš¾å åŠ å½¢æˆçœŸæ­£çš„é»‘è‰²ï¼Œå› æ­¤å¼•å…¥äº†Kâ€”â€”é»‘è‰²ã€‚é»‘è‰²çš„ä½œç”¨æ˜¯å¼ºåŒ–æš—è°ƒï¼ŒåŠ æ·±æš—éƒ¨è‰²å½©ã€‚\nâ–  YUV(Y, U, V)æ˜¯ä¸€ç§åŸºäºäº®åº¦å’Œè‰²åº¦åˆ†é‡çš„é¢œè‰²ç©ºé—´ï¼Œé€šå¸¸ç”¨äºè§†é¢‘å‹ç¼©å’Œå¹¿æ’­ä¸­ã€‚åœ¨YUVæ¨¡å‹ä¸­ï¼ŒYè¡¨ç¤ºäº®åº¦åˆ†é‡ï¼ˆå³ç°åº¦ä¿¡æ¯ï¼‰ï¼ŒUå’ŒVè¡¨ç¤ºè‰²åº¦åˆ†é‡ï¼ˆå³é¢œè‰²ä¿¡æ¯ï¼ŒUè¡¨ç¤ºè“è‰²æŠ•å½±ï¼ŒVè¡¨ç¤ºçº¢è‰²æŠ•å½±ï¼‰ã€‚YUVçš„å¥½å¤„åœ¨äºï¼Œå®ƒèƒ½å¤Ÿå°†äº®åº¦å’Œè‰²åº¦åˆ†å¼€å¤„ç†ï¼Œè¿™å¯¹äºå›¾åƒå’Œè§†é¢‘å‹ç¼©å¾ˆæœ‰å¸®åŠ©ï¼Œå› ä¸ºäººçœ¼å¯¹äº®åº¦çš„æ•æ„Ÿåº¦è¿œé«˜äºè‰²åº¦ï¼Œå› æ­¤å¯ä»¥å¯¹è‰²åº¦åˆ†é‡è¿›è¡Œè¾ƒé«˜çš„å‹ç¼©è€Œä¸æ˜¾è‘—å½±å“è§†è§‰è´¨é‡ã€‚\nRGB-YUV è½¬æ¢å…¬å¼ âœ– $$\\begin{aligned} \u0026Y=W_RR^{\\prime}+W_GG^{\\prime}+W_BB^{\\prime}=0.299R^{\\prime}+0.587G^{\\prime}+0.114B^{\\prime} \\\\ \u0026U=U_{\\mathrm{max}}\\frac{B^{\\prime}-Y^{\\prime}}{1-W_{B}}\\approx0.492(B^{\\prime}-Y^{\\prime}) \\\\ \u0026V=V_{\\mathrm{max}}\\frac{R^{\\prime}-Y^{\\prime}}{1-W_{R}}\\approx0.877(R^{\\prime}-Y^{\\prime}) \\\\ \u0026\\Rightarrow \\begin{bmatrix}Y\\\\U\\\\V\\end{bmatrix}=\\begin{bmatrix}0.299\u00260.587\u00260.114\\\\-0.14713\u0026-0.28886\u00260.436\\\\0.615\u0026-0.51499\u0026-0.10001\\end{bmatrix}\\begin{bmatrix}R'\\\\G'\\\\B'\\end{bmatrix} \\\\ \u0026R^{\\prime}=Y^{\\prime}+V\\frac{1-W_{R}}{V_{\\mathrm{max}}}=Y^{\\prime}+\\frac{V}{0.877}=Y^{\\prime}+1.14V \\\\ \u0026B^{\\prime}=Y^{\\prime}+U\\frac{1-W_{B}}{U_{\\max}}=Y^{\\prime}+\\frac{U}{0.492}=Y^{\\prime}+2.033U \\\\ \u0026G^{\\prime}=\\frac{Y'-W_RR'-W_BB'}{W_G} \\\\ \u0026\\Rightarrow \\begin{bmatrix}R'\\\\G'\\\\B'\\end{bmatrix}=\\begin{bmatrix}1\u00260\u00261.13983\\\\1\u0026-0.39465\u0026-0.58060\\\\1\u00262.03211\u00260\\end{bmatrix}\\begin{bmatrix}Y\\\\U\\\\V\\end{bmatrix} \\end{aligned}$$ â–  HSV(Hue, Saturation, Value)æ˜¯æ ¹æ®é¢œè‰²çš„ç›´è§‚ç‰¹æ€§ç”±A. R. Smithåœ¨1978å¹´åˆ›å»ºçš„ä¸€ç§é¢œè‰²ç©ºé—´, ä¹Ÿç§°å…­è§’é”¥ä½“æ¨¡å‹(Hexcone Model)ã€‚è¿™ä¸ªæ¨¡å‹ä¸­é¢œè‰²çš„å‚æ•°åˆ†åˆ«æ˜¯ï¼šè‰²è°ƒï¼ˆHï¼‰ï¼Œé¥±å’Œåº¦ï¼ˆSï¼‰ï¼Œæ˜åº¦ï¼ˆVï¼‰ã€‚\nâ–  HSL(Hue, Saturation, Lightness)æ˜¯HSVæ¨¡å‹çš„å˜ä½“ï¼Œä¹Ÿæ˜¯ç”±è‰²è°ƒã€é¥±å’Œåº¦å’Œäº®åº¦ä¸‰ä¸ªå‚æ•°æ¥æè¿°é¢œè‰²çš„ã€‚ä¸HSVä¸åŒï¼ŒHSLä¸­çš„äº®åº¦ï¼ˆLightnessï¼‰æŒ‡çš„æ˜¯ä»é»‘è‰²åˆ°ç™½è‰²çš„äº®åº¦ç¨‹åº¦ï¼Œä½äº0åˆ°100ä¹‹é—´ï¼Œè€ŒHSVä¸­çš„æ˜åº¦ï¼ˆValueï¼‰åˆ™æ˜¯ä»é»‘è‰²åˆ°æœ€äº®çš„é¢œè‰²çš„äº®åº¦ç¨‹åº¦ã€‚HSLæ¨¡å‹å¸¸ç”¨äºè®¡ç®—æœºå›¾å½¢å’Œå›¾åƒå¤„ç†é¢†åŸŸï¼Œå› ä¸ºå®ƒä¸äººçœ¼å¯¹é¢œè‰²çš„æ„ŸçŸ¥æ›´ä¸ºæ¥è¿‘ã€‚\nRGBåˆ°HSVå’ŒHSLçš„è½¬æ¢æ¯”è¾ƒå¤æ‚ï¼Œå‚è€ƒwikiç™¾ç§‘HSL_and_HSV\nç¤ºä¾‹ä»£ç  âœ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // RGB è½¬ YUV std::array\u0026lt;float, 3\u0026gt; rgbToYuv(const std::array\u0026lt;float, 3\u0026gt;\u0026amp; rgb) { float y = 0.299f * rgb[0] + 0.587f * rgb[1] + 0.114f * rgb[2]; float u = 0.492f * (rgb[2] - y); float v = 0.877f * (rgb[0] - y); return {y, u, v}; } // YUV è½¬ RGB std::array\u0026lt;float, 3\u0026gt; yuvToRgb(const std::array\u0026lt;float, 3\u0026gt;\u0026amp; yuv) { float r = yuv[0] + 1.14f * yuv[2]; float g = yuv[0] - 0.394f * yuv[1] - 0.581f * yuv[2]; float b = yuv[0] + 2.032f * yuv[1]; return {r, g, b}; } Refferenceï¼š\nhttps://www.qinxing.xyz/posts/506138d8/\nhttps://github.com/yuqing-liu-dut/ISPLab\nhttps://www.bilibili.com/video/BV1LA4m1N78h\nhttps://www.wpgdadatong.com.cn/blog/detail/42592\nhttps://www.cnblogs.com/lanlancky/p/17498055.html#_label2_0\nhttps://www.cnblogs.com/wnwin/p/11985194.html\nhttps://www.cnblogs.com/sunny-li/p/8641767.html\nhttps://blog.csdn.net/hhy321/article/details/120896015\n","date":"2024-11-11T10:35:55.591Z","image":"https://RoboticsChen.github.io/articles/camera-isp/raw_image_hu_72fbad4f17692848.png","permalink":"https://RoboticsChen.github.io/articles/camera-isp/","title":"ç›¸æœºæˆåƒä¸ISP"}]